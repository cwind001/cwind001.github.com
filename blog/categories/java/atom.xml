<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 辰风君的笔记本]]></title>
  <link href="http://cwind001.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://cwind001.github.io/"/>
  <updated>2017-08-31T00:39:25+08:00</updated>
  <id>http://cwind001.github.io/</id>
  <author>
    <name><![CDATA[辰风君]]></name>
    <email><![CDATA[billchen01@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java 8 Stream API 实战]]></title>
    <link href="http://cwind001.github.io/blog/2017/03/20/java8-stream-api-in-action/"/>
    <updated>2017-03-20T00:17:11+08:00</updated>
    <id>http://cwind001.github.io/blog/2017/03/20/java8-stream-api-in-action</id>
    <content type="html"><![CDATA[<p>谈起Java Stream API，我们希望能够弄明白它究竟是什么，能够用来做什么，有什么优势，并能够应用于具体场景。分别简述如下。</p>

<h2 id="section">不是什么</h2>
<ul>
  <li>Java Stream API 不是输入输出流，与java.io包里的InputStream和OutputStream概念完全不同</li>
  <li>不是用于解析XML的XMLStream</li>
  <li>不是Valve公司的<a href="http://store.steampowered.com/">游戏平台</a>  </li>
  <li>也不是集合元素，不是数据结构不保存数据</li>
</ul>

<h2 id="section-1">是什么</h2>
<ul>
  <li>是Java 8 中引入的新特性，是对集合（Collection）对象功能的增强</li>
  <li>是关于算法和计算的，更像一个高级版本的迭代器（Iterator）</li>
</ul>

<!--more-->

<h2 id="section-2">能够用来做什么</h2>
<p>用于对集合对象进行各种便利、高效的聚合操作，或大批量数据操作</p>

<h2 id="section-3">有何优势</h2>
<p>以往对于集合的聚合操作，需要使用Iterator遍历集合，代码繁冗；对于过滤和计算得到的中间结果，需要额外的空间进行存储<br />
Java Stream API解决了以上问题，遍历逻辑可以精简为一行，使得代码更加简洁易读。<br />
Java Stream提供串行和并行两种模式进行汇聚操作，能够充分利用多核处理器的优势，更方便写出高性能的并发程序且不易出错</p>

<h2 id="section-4">典型应用场景</h2>
<p><a href="https://github.com/cwind001/CwindJavaLab/blob/8cc89129a5ef3d288b59e02e4924ba2d7a597838/AdvancedJava/src/main/java/com/cwind/java8/stream/StreamAPIDemo.java">StreamAPIDemo</a><br />
定义商品对象并初始化购物清单如下：  </p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="directive">public</span> <span class="type">class</span> <span class="class">StreamAPIDemo</span> {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="directive">private</span> <span class="predefined-type">List</span>&amp;lt;Item&amp;gt; shoppingList;

<span class="annotation">@Before</span>
<span class="directive">public</span> <span class="type">void</span> setUp() <span class="directive">throws</span> <span class="exception">Exception</span> {
    shoppingList = Lists.newArrayList();
    shoppingList.add(<span class="keyword">new</span> Item(<span class="string"><span class="delimiter">&quot;</span><span class="content">iPhone 7</span><span class="delimiter">&quot;</span></span>, <span class="integer">7250L</span>));
    shoppingList.add(<span class="keyword">new</span> Item(<span class="string"><span class="delimiter">&quot;</span><span class="content">Rolex Watch</span><span class="delimiter">&quot;</span></span>, <span class="integer">28888L</span>));
    shoppingList.add(<span class="keyword">new</span> Item(<span class="string"><span class="delimiter">&quot;</span><span class="content">Electric Toothbrush</span><span class="delimiter">&quot;</span></span>, <span class="integer">388L</span>));
    shoppingList.add(<span class="keyword">new</span> Item(<span class="string"><span class="delimiter">&quot;</span><span class="content">Kindle Paperwhite</span><span class="delimiter">&quot;</span></span>, <span class="integer">1098L</span>));
    shoppingList.add(<span class="keyword">new</span> Item(<span class="string"><span class="delimiter">&quot;</span><span class="content">Coca Cola</span><span class="delimiter">&quot;</span></span>, <span class="integer">3L</span>));
}
<span class="type">class</span> <span class="class">Item</span> {
    <span class="predefined-type">String</span> itemName;
    <span class="type">long</span> price;

    <span class="directive">public</span> Item(<span class="predefined-type">String</span> itemName, <span class="type">long</span> price) {
        <span class="local-variable">this</span>.itemName = itemName;
        <span class="local-variable">this</span>.price = price;
    }
} } </pre></div>
</div>
 </figure>  
</code></pre>

<h3 id="section-5">集合遍历</h3>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
    <span class="comment">// 打印购物清单</span>
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> printShoppingList(){
        shoppingList.stream().forEach(<span class="predefined-type">System</span>.out::println);
    }
</pre></div>
</div>
 </figure><br />
输出：  </p>

<p><code>
Item{itemName='iPhone 7', price=7250}
Item{itemName='Rolex Watch', price=28888}
Item{itemName='Electric Toothbrush', price=388}
Item{itemName='Kindle Paperwhite', price=1098}
Item{itemName='Coca Cola', price=3}
</code></p>

<h3 id="section-6">数学统计</h3>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
    <span class="comment">// 统计购物清单总数与总价</span>
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> printTotalPrice() {
        <span class="type">long</span> itemNum = shoppingList.stream().count();
        <span class="predefined-type">System</span>.out.println(<span class="error">“</span>Sum of items in the shopping list: <span class="error">“</span> + itemNum);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    <span class="type">long</span> totalPrice = shoppingList.stream().collect(Collectors.summingLong(Item::getPrice));
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Total price: </span><span class="delimiter">&quot;</span></span> + totalPrice);
} </pre></div>
</div>
 </figure>   输出：  
</code></pre>

<p><code>
Sum of items in the shopping list: 5
Total price: 37627
</code></p>

<h3 id="section-7">过滤与排序</h3>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
    <span class="comment">// 过滤价格小于1000的商品</span>
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> filterItems(){
        shoppingList.stream().filter(p -&amp;gt; p.getPrice() &amp;gt;= <span class="integer">1000L</span>).forEach(<span class="predefined-type">System</span>.out::println);
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="comment">// 按价格排序</span>
<span class="annotation">@Test</span>
<span class="directive">public</span> <span class="type">void</span> sortItemsByPrice(){
    shoppingList.stream().sorted(<span class="predefined-type">Comparator</span>.comparingLong(Item::getPrice)).forEach(<span class="predefined-type">System</span>.out::println);
} </pre></div>
</div>
 </figure>  
</code></pre>

<h3 id="mapreduce">MapReduce(映射与规约)</h3>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
    <span class="comment">// 所有商品价格减100 - Map</span>
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> streamMap(){
        shoppingList.stream().map(p -&amp;gt; <span class="keyword">new</span> Item(p.getItemName(), p.getPrice()-<span class="integer">100</span>)).forEach(<span class="predefined-type">System</span>.out::println);
    }
</pre></div>
</div>
 </figure>  </p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
    <span class="comment">// 取出如上优惠之后金额超过1000元的商品中，价格最低的商品（最便宜的奢侈品）</span>
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> streamReduce(){
        Item cheapestLuxury = shoppingList.stream().map(p -&amp;gt; <span class="keyword">new</span> Item(p.getItemName(), p.getPrice()-<span class="integer">100</span>))
            .filter(p -&amp;gt; p.getPrice() &amp;gt; <span class="integer">1000</span>).reduce((a, b) -&amp;gt; a.getPrice()&amp;lt;b.getPrice()?a:b).get();
        <span class="predefined-type">System</span>.out.println(cheapestLuxury);
    }
</pre></div>
</div>
 </figure>  </p>

<h2 id="section-8">参考</h2>
<ul>
  <li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/">Java 8 中的Streams API 详解</a> </li>
  <li><a href="http://blog.csdn.net/io_field/article/details/54971679">Java 8系列之Stream中万能的reduce</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[轻量级框架与重量级框架]]></title>
    <link href="http://cwind001.github.io/blog/2015/05/11/lightweight-framework-vs-heavyweight-framework/"/>
    <updated>2015-05-11T22:31:22+08:00</updated>
    <id>http://cwind001.github.io/blog/2015/05/11/lightweight-framework-vs-heavyweight-framework</id>
    <content type="html"><![CDATA[<p>事实上“轻量级”与“重量级”并没有确切的定义。轻重量级之分应当考虑如下几个方面：  </p>

<h3 id="section">加载的资源</h3>

<p>Spring相对于EJB是轻量级的，但这就好像说大象比鲸轻。<br />
如果你想要运行一个Java EE应用程序，你不能够简单地创建一个应用并直接运行它本身。需要一个JavaEE服务器来运行应用，例如Glassfish，WebLogic或WebSphere。多数应用服务器都是非常巨大并且复杂的，并不容易安装和配置。  </p>

<p>EJB应用启动时要消耗大量的资源，内存、CPU等，把所有的服务都加载进来；Spring则是可定制服务，需要什么加载什么。<br />
<!--more-->  </p>

<h3 id="section-1">侵入性（或曰框架依赖性，耦合性）</h3>

<p>重量级框架（如EJB2.0和Struts1.2）侵入性较高。它强制开发者写一些与框架绑定的类。这使得这些类很难被测试。<br />
Spring将侵入性降到最低，它允许使用POJO进行开发。Spring并不强制实现Spring API接口或扩展Spring API类。这使得这些类方便测试。这使得把类迁移到其他轻量级容器更加容易。  </p>

<h3 id="section-2">开发的方便程度</h3>
<p>如上条所述，使用重量级框架要写一些框架绑定的类，部署、运行及测试过程都较为复杂，开发起来并不方便。而轻量级框架反之。  </p>

<h2 id="section-3">解决问题的侧重点不同：</h2>
<p>轻量级框架侧重于减小开发的复杂度，相应它的处理能力较弱（事务功能弱，不具备分布式处理能力），适用于开发中小型企业应用。
重量级框架则强调高可伸缩性，适合于开发大型企业应用。  </p>

<h2 id="section-4">轻量级框架的特点：</h2>
<p>一般是非侵入性的、依赖的东西非常少，占用资源非常少，部署简单，比较容易使用。  </p>

<h2 id="spring">为何说Spring是轻量级框架：</h2>
<ul>
  <li>Spring以集中的、自动化的方式进行应用程序对象创建和装配，管理对象生命周期，组合成复杂的应用程序。  </li>
  <li>Spring提供了不同的模块，基于需求可以灵活选择。Spring jar的大小通常在几MB。  </li>
  <li>相比较EJB，Spring需要写更少的代码和更少的配置。使得开发人员能够更关注业务逻辑。  </li>
  <li>Spring容器是非侵入性的，完全采用POJO进行开发，方便测试。  </li>
  <li>Spring方便与其他框架与第三方类库无缝集成。  </li>
</ul>

<p>Spring与其他基于POJO的容器相比，例如Guice和Plexus，仍然称得上是“重量级”。因为完整的Spring技术栈包含了POJO之上的层次，它的MVC框架需要Servlets基础设施。<br />
Spring相比EJB2.x确实是轻量级，最主要的卖点是POJO的使用。  </p>

<h2 id="ejb">为何说EJB是重量级框架？</h2>
<p>首先这是Rod Johnson说的，Spring狂热者奉之为圭臬的论断。<br />
2004年以前EJB2.x确实是重量级，它需要EJB容器来运行，需要加载较多的资源，代码侵入性较高–需要实现特定的EJB接口，相对来说开发并不方便。  </p>

<h2 id="section-5">总结</h2>
<p>轻重量级是相对的，主要从加载资源、代码侵入性和开发便捷性等方面去考虑和比较。类似地，使用volatile变量可以用来确保变量的更新操作被同步到其他线程，这种同步机制相对于同步容器就是轻量级的（当然更具可伸缩性和实用性的是并发容器而非上述二者）；而jetty相对于tomcat而言，由于其加载资源更少，也可以称之为轻量级的。  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java读写Excel：Apache POI, JXL与OpenCSV]]></title>
    <link href="http://cwind001.github.io/blog/2015/02/27/apachepoi/"/>
    <updated>2015-02-27T07:53:53+08:00</updated>
    <id>http://cwind001.github.io/blog/2015/02/27/apachepoi</id>
    <content type="html"><![CDATA[<p>前些日子把JXL替换为ApachePOI，原因很简单，JXL在2009年10月已经停止更新，并且不支持Excel 2007 OOXML （.xlsx）格式的文件。事实上把JXL与POI进行比较并不公平，因为JXL只能够操作OLE2格式的Excel（即.xls），而POI则是能够读写xls(x)、doc(x)、ppt(x)的一整套解决方案。<br />
<!--more--></p>

<p>不同版本Excel的行列数限制：  </p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre> &lt;br /&gt;
+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span>+
|                 | Max. Rows | Max. Columns | Max. Cols by letter |
+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span>+
| Excel <span class="integer">365</span>*      | <span class="integer">1</span>,<span class="integer">048</span>,<span class="integer">576</span> | <span class="integer">16</span>,<span class="integer">384</span>       | XFD                 |
| Excel <span class="integer">2013</span>      | <span class="integer">1</span>,<span class="integer">048</span>,<span class="integer">576</span> | <span class="integer">16</span>,<span class="integer">384</span>       | XFD                 |
| Excel <span class="integer">2010</span>      | <span class="integer">1</span>,<span class="integer">048</span>,<span class="integer">576</span> | <span class="integer">16</span>,<span class="integer">384</span>       | XFD                 |
| Excel <span class="integer">2007</span>      | <span class="integer">1</span>,<span class="integer">048</span>,<span class="integer">576</span> | <span class="integer">16</span>,<span class="integer">384</span>       | XFD                 |
| Excel <span class="integer">2003</span>      | <span class="integer">65</span>,<span class="integer">536</span>    | <span class="integer">256</span>          | IV                  |
| Excel <span class="integer">2002</span> (XP) | <span class="integer">65</span>,<span class="integer">536</span>    | <span class="integer">256</span>          | IV                  |
| Excel <span class="integer">2000</span>      | <span class="integer">65</span>,<span class="integer">536</span>    | <span class="integer">256</span>          | IV                  |
| Excel <span class="integer">97</span>        | <span class="integer">65</span>,<span class="integer">536</span>    | <span class="integer">256</span>          | IV                  |
| Excel <span class="integer">95</span>        | <span class="integer">16</span>,<span class="integer">384</span>    | <span class="integer">256</span>          | IV                  |
| Excel <span class="integer">5</span>         | <span class="integer">16</span>,<span class="integer">384</span>    | <span class="integer">256</span>          | IV                  |
+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">–</span>+<span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span><span class="error">—</span>+&lt;br /&gt;
</pre></div>
</div>
 </figure> </p>

<p><em>*Excel 365 unverified.</em></p>

<p><strong>JXL - JExcelApi</strong><br />
<a href="http://mvnrepository.com/artifact/net.sourceforge.jexcelapi/jxl/2.6.12">Maven Repo</a><br />
<a href="http://www.andykhan.com/jexcelapi/index.html">官方网站</a><br />
最近更新：Oct 24，2009</p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>   &lt;/p&gt;
&lt;dependency&gt;
 &lt;groupid&gt;net.sourceforge.jexcelapi&lt;/groupid&gt;
 &lt;artifactid&gt;jxl&lt;/artifactid&gt;
 &lt;version&gt;<span class="float">2.6</span><span class="float">.12</span>&lt;/version&gt;
&lt;/dependency&gt;
&lt;p&gt;</pre></div>
</div>
 </figure>   </p>

<p>JXL是一个日本人写的简单类库。<a href="http://www.jexcelapi.org/">作者主页</a>。<a href="http://blog.csdn.net/jarvis_java/article/details/4924099">POI和jxl.jar性能比较</a>一贴中提到其性能较poi更高，内存消耗更少。当且仅当目标文档是行数接近但不超过65536的xls格式时成立。  </p>

<p>类图：<br />
<img src="http://dl.iteye.com/upload/picture/pic/132574/73b48deb-3ba5-396c-b01c-5546b1aecba0.jpg">  </p>

<p><figure class='code'><figcaption class='code-header'><span>JXL Demo</span> &mdash; <a href='https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/jxl/JXLDataSheetWriter.java'>link</a></figcaption> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
</pre></td>
  <td class="code"><pre> &lt;br /&gt;
 <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
  <span class="keyword">try</span> {
   <span class="comment">// create writable wookbook</span>
   WritableWorkbook workbook 
    = Workbook.createWorkbook(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="error">“</span>jxlOutput.xls<span class="error">”</span>));&lt;/p&gt;

&lt;p&gt;<span class="comment">// create writable sheet</span>
   WritableSheet sheet = workbook.createSheet(<span class="error">“</span>First Sheet<span class="error">”</span>, <span class="integer">0</span>);
   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="integer">0</span>; i &amp;lt; data.length; i++) {
    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="integer">0</span>; j &amp;lt; data[i].length; j++){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; <span class="comment">// create a cell at position (i, j) and add to the sheet</span>
 <span class="predefined-type">Label</span> label = <span class="keyword">new</span> <span class="predefined-type">Label</span>(i, j, data[i][j]);
 sheet.addCell(label);
}    }    workbook.write();    workbook.close();   } <span class="keyword">catch</span> (<span class="exception">IOException</span> | WriteException e) {    e.printStackTrace();   }  } </pre></td>
</tr></table>
 </figure> 
</code></pre>

<p><strong>Apache POI</strong><br />
<a href="http://mvnrepository.com/artifact/org.apache.poi/poi">Maven Repo</a><br />
<a href="http://poi.apache.org/">官方网站</a><br />
最近更新：Dec 17，2014  </p>

<p>类图：<br />
<img src="http://dl.iteye.com/upload/picture/pic/132576/6230920a-edc2-3e7c-ac23-d4590f095048.jpg"> </p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>   &lt;/p&gt;
&lt;dependency&gt; 
  &lt;groupid&gt;org.apache.poi&lt;/groupid&gt;
  &lt;artifactid&gt;poi&lt;/artifactid&gt;
  &lt;version&gt;<span class="float">3.10</span><span class="float">.1</span>&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
     &lt;groupid&gt;org.apache.poi&lt;/groupid&gt;
     &lt;artifactid&gt;poi-ooxml&lt;/artifactid&gt;
     &lt;version&gt;<span class="float">3.9</span>&lt;/version&gt;
 &lt;/dependency&gt;
&lt;p&gt;</pre></div>
</div>
 </figure>   </p>

<p><strong>Apache POI API的一些重点：</strong></p>

<ul>
  <li>Apache POI包含 Excel 97(-2007)文件格式(.xls)的Java实现 – HSSF。（彩蛋：H指Horrible）  </li>
  <li>Apache POI包含 Excel 2007 OOXML文件格式(.xlsx)的Java实现 – XSSF。  </li>
  <li>Apache POI的HSSF和XSSF API提供了读写和修改Excel电子表格的功能。  </li>
  <li>Apache POI也提供了SXSSF API（流式XSSF），它是XSSF的扩展，用于写入非常大的excel文件。SXSSF API需求较小的内存，适用于在堆内存受限时处理较大excel文件的情况。  </li>
  <li>可以选择两种模型：Event Model和User Model。Event Model需求较小的内存，流式读取并处理每个单元；User Model更具备面向对象的特征，方便操作。  </li>
  <li>Apache POI提供了对excel附加功能的完美支持，如公式、单元格样式、颜色、字体、数据验证、图像和超链接等。  </li>
</ul>

<p>SpreadSheet API 功能摘要：<br />
<img src="http://dl.iteye.com/upload/picture/pic/132578/9b044f00-622e-3a07-9471-3ee912e42819.jpg"> <br />
以下是两个基于XSSF读写xlsx文件的例子：<br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/poi/SimpleDatasheetReader.java">读取xlsx文件</a><br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/poi/SimpleDatasheetWriter.java">写入xlsx文件</a>  </p>

<p><strong>OpenCSV：</strong> <br />
CSV文件以纯文本形式存储表格数据（数字和文本）。OpenCSV是一个用于读写CSV文件的简单Java类库。<br />
<a href="http://mvnrepository.com/artifact/net.sf.opencsv/opencsv/2.3">Maven Repo</a><br />
<a href="http://opencsv.sf.net">官方网站</a><br />
最近更新：Jul 28，2011</p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>  &lt;/p&gt;
&lt;dependency&gt;
 &lt;groupid&gt;net.sf.opencsv&lt;/groupid&gt;
 &lt;artifactid&gt;opencsv&lt;/artifactid&gt;
 &lt;version&gt;<span class="float">2.3</span>&lt;/version&gt;
&lt;/dependency&gt;
&lt;p&gt;</pre></div>
</div>
 </figure></p>

<p>OpenCSV将CSV文件中的每一行读取为一个String数组。相应地，写文件时通过<code>csvWriter.writeNext(array)</code>把String数组内容作为一行写入CSV文件</p>

<p>读写CSV文件的例子：<br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/opencsv/ReadCSVDemo.java">读取csv文件内容</a><br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/opencsv/OpenCSVDemo.java">将xlsx文件内容写入csv</a>  </p>

<p><strong>References:</strong><br />
1. <a href="http://poi.apache.org/spreadsheet/">POI-HSSF and POI-XSSF - Java API To Access Microsoft Excel Format Files</a><br />
2. <a href="http://www.journaldev.com/2562/java-readwrite-excel-file-using-apache-poi-api">Java Read/Write Excel File using Apache POI API</a>  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java文件变更监控的两种实现]]></title>
    <link href="http://cwind001.github.io/blog/2015/01/30/java-file-monitor/"/>
    <updated>2015-01-30T14:25:04+08:00</updated>
    <id>http://cwind001.github.io/blog/2015/01/30/java-file-monitor</id>
    <content type="html"><![CDATA[<p><strong>对文件及文件夹进行修改变更监测有很广泛的应用，例如：</strong>  </p>

<ul>
  <li>通知配置文件的改变  </li>
  <li>跟踪某些关键的系统文件的变化  </li>
  <li>监控某个分区磁盘的整体使用情况  </li>
  <li>系统崩溃时进行自动清理<br />
<!--more--></li>
  <li>自动触发备份进程  </li>
  <li>向服务器上传文件结束时发出通知    </li>
</ul>

<p>下面给出Java的两种实现，源码可以在GitHub上找到 <a href="https://github.com/cwind001/CwindJavaLab/tree/master/FileMonitor">FileMonitor</a></p>

<p><strong>JDK1.6及之前版本: 基于Timer实现</strong><br />
<strong>两个关键类：</strong>  </p>

<ul>
  <li>java.util.Timer  </li>
  <li>java.util.TimerTask</li>
</ul>

<p>Timertask是由Timer执行的实际任务，实现了Rannable接口。通过重写run()方法来指定具体任务细节。<br />
<img src="http://dl2.iteye.com/upload/attachment/0105/5397/ddf9a7c5-f08a-3fd3-b1f8-6859e1054bd8.jpg"></p>

<p><strong>Timer工作原理：</strong><br />
Timer是用于调度一次性执行或重复执行的工具类。通过TaskQueue保存需要调度的TimerTask，当某个Task被废弃时（一次性任务结束或TimerTask.cancel()），将其从该队列中移除。<br />
Timer类维护一个后台线程（守护线程或用户线程，取决于如何创建Timer对象），该线程通常称为Timer任务执行线程。在TimerThread的mainLoop()中依据各个TimerTask的状态和调度时间设定，决定执行或移除TimerTask。<br />
<strong>TimerTask应设计为执行不占用太长时间</strong>，否则同一个Timer队列中其他的TimerTask的执行将会延迟。<br />
更多可参见：<a href="http://javarevisited.blogspot.com/2013/02/what-is-timer-and-timertask-in-java-example-tutorial.html">What is Timer and TimerTask in Java</a></p>

<p><strong>基于Timer的FileMonitor的实现：</strong><br />
<img src="http://dl2.iteye.com/upload/attachment/0105/5399/4b7c54fa-cac9-3d7b-85c7-6e655ff8bbcb.jpg"></p>

<p>通过实现FileChangeObserver接口，该FileMonitor允许对任意文件添加任意多个Observer。<br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/FileMonitor/src/main/java/com/cwind/file/FileChangeMonitor.java">FileChangeMonitor及FileChangeTask源码</a><br />
FileChangeMonitor本身是一个单例。fileObservers由Collections.synchronizedMap()初始化，保证在该map上的每一个原子操作都将被同步。在其addObserver方法中为每一个fileChangeObserver创建一个FileChangeTask，将其加入fileObservers中。FileChangeTask扩展了TimerTask，由Timer调度执行。</p>

<p><figure class='code'><figcaption class='code-header'><span>FileChangeMonitor.addObserver()</span> &mdash; <a href='https://github.com/cwind001/CwindJavaLab/blob/master/FileMonitor/src/main/java/com/cwind/file/FileChangeMonitor.java'>link</a></figcaption> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>
    <span class="directive">public</span> <span class="type">void</span> addObserver(FileChangeObserver observer, 
      <span class="predefined-type">String</span> filename, <span class="type">long</span> delay) <span class="directive">throws</span> <span class="exception">FileNotFoundException</span> {&lt;br /&gt;
        <span class="predefined-type">TimerTask</span> task = <span class="keyword">new</span> FileChangeTask(observer , filename );&lt;br /&gt;
        <span class="predefined-type">List</span>&lt;timertask&gt; tasks = fileObservers.get(filename );  
        <span class="keyword">if</span>(tasks ==<span class="predefined-constant">null</span>){  
            tasks = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;timertask&gt;();  
           }  
        tasks.add( task);  
        fileObservers.put(filename , tasks );  
        timer.schedule( task, delay, delay);  
    }  
</pre></td>
</tr></table>
 </figure>  
在FileChangeTask的run()函数中，通过比对时间戳来判断文件是否修改，若发生改动，则通知其Observer进行相应处理。 </timertask></timertask></p>

<p><figure class='code'><figcaption class='code-header'><span>FileChangeTask.run()</span> &mdash; <a href='https://github.com/cwind001/CwindJavaLab/blob/master/FileMonitor/src/main/java/com/cwind/file/FileChangeMonitor.java'>link</a></figcaption> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
</pre></td>
  <td class="code"><pre>&lt;br /&gt;
<span class="directive">public</span> <span class="type">void</span> run() {
        <span class="keyword">try</span>    {
            <span class="type">long</span> newLastModified = file.lastModified();
            <span class="keyword">if</span> (newLastModified &amp;gt; lastModified) {
                lastModified = newLastModified;
                observer.fileChanged(file.getPath());
            }
        }
        <span class="keyword">catch</span> (<span class="exception">Exception</span> e)    {
            <span class="predefined-type">System</span>.err.println(e.getMessage());
        }
    } 
</pre></td>
</tr></table>
 </figure> </p>

<p>测试用例<a href="https://github.com/cwind001/CwindJavaLab/blob/163448ce07ecca1738b306bed9bf1b39464d345c/FileMonitor/src/test/java/com/cwind/file/FileMonitorTest.java">FileMonitorTest</a>中为sample1.txt添加了consoleObserver和emailObserver，为sample2.txt添加了consoleObserver。然后对这两个文件分别进行修改。</p>

<p><figure class='code'><figcaption class='code-header'><span>FileMonitorTest</span> &mdash; <a href='https://github.com/cwind001/CwindJavaLab/blob/163448ce07ecca1738b306bed9bf1b39464d345c/FileMonitor/src/test/java/com/cwind/file/FileMonitorTest.java'>link</a></figcaption> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">package</span> <span class="namespace">com.cwind.file</span>;&lt;/p&gt;

&lt;p&gt;<span class="keyword">import</span> <span class="include">java.io.File</span>;
<span class="keyword">import</span> <span class="include">java.io.FileOutputStream</span>;
<span class="keyword">import</span> <span class="include">java.io.IOException</span>;&lt;/p&gt;

&lt;p&gt;<span class="keyword">import</span> <span class="include">org.junit.After</span>;
<span class="keyword">import</span> <span class="include">org.junit.Before</span>;
<span class="keyword">import</span> <span class="include">org.junit.Test</span>;&lt;/p&gt;

&lt;p&gt;<span class="directive">public</span> <span class="type">class</span> <span class="class">FileMonitorTest</span> {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="predefined-type">File</span> sampleFile1, sampleFile2;
FileChangeMonitor monitor;
ConsoleFileChangeObserver consoleObserver;
EmailFileChangeObserver emailObserver;

<span class="annotation">@Before</span>
<span class="directive">public</span> <span class="type">void</span> setUp() <span class="directive">throws</span> <span class="exception">Exception</span> {
    sampleFile1 = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">sample1.txt</span><span class="delimiter">&quot;</span></span>); 
    sampleFile2 = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">sample2.txt</span><span class="delimiter">&quot;</span></span>);
    monitor = FileChangeMonitor.getInstance();
    consoleObserver = <span class="keyword">new</span> ConsoleFileChangeObserver();
    emailObserver = <span class="keyword">new</span> EmailFileChangeObserver(<span class="string"><span class="delimiter">&quot;</span><span class="content">billchen01@163.com</span><span class="delimiter">&quot;</span></span>);
}

<span class="annotation">@After</span>
<span class="directive">public</span> <span class="type">void</span> tearDown() <span class="directive">throws</span> <span class="exception">Exception</span>    {
    
}

<span class="annotation">@Test</span>
<span class="directive">public</span> <span class="type">void</span> testMonitorSampleFile() <span class="directive">throws</span> <span class="exception">InterruptedException</span>, 
    <span class="exception">IOException</span>{
    monitor.addObserver(consoleObserver, sampleFile1.getPath(), 
        FileChangeMonitor.DELAY_TIME);
    monitor.addObserver(emailObserver, sampleFile1.getPath(), 
        FileChangeMonitor.DELAY_TIME);
    monitor.addObserver(consoleObserver, sampleFile2.getPath(), 
        FileChangeMonitor.DELAY_TIME);
    
    <span class="predefined-type">FileOutputStream</span> fos1 = <span class="keyword">new</span> <span class="predefined-type">FileOutputStream</span>(sampleFile1);
    <span class="predefined-type">FileOutputStream</span> fos2 = <span class="keyword">new</span> <span class="predefined-type">FileOutputStream</span>(sampleFile2);
    fos1.write(<span class="integer">0</span>);
    fos2.write(<span class="integer">0</span>);
    fos1.flush();
    fos2.flush();
    fos1.close();
    fos2.close();
    <span class="predefined-type">Thread</span>.sleep(<span class="integer">3000</span>);
} } </pre></td>
</tr></table>
 </figure> 
</code></pre>

<p>输出结果如下：<br />
<code>Console: File sample1.txt is changed, will print warning message to console.</code><br />
<code>File sample1.txt is changed, will send email to billchen01@163.com.</code><br />
<code>Console: File sample2.txt is changed, will print warning message to console.</code>  </p>

<p><strong>JDK 1.7 及之后版本：基于WatchService实现</strong><br />
Java 7 的新IO - NIO.2提供了一组新的类和方法，主要存在于java.nio包内。它完全取代了java.io.File与文件系统的交互，并提供了新的异步处理类，无需手动配置线程池和其他底层并发控制，便可在后台线程中执行文件和网络IO操作。<br />
其中Path是新文件IO的基石。为与之前版本兼容，java.io.File类中新增了toPath()方法，Path类中提供了toFile()方法。
Watch Service API可用于将指定目录注册到监视服务上。注册时须指定事件类型，如文件创建、修改、删除等。相关类图如下：<br />
<img src="http://dl2.iteye.com/upload/attachment/0105/5403/f20e959b-2ded-3a35-b984-61f5010f7efb.jpg">  </p>

<p>WatchService是监视服务接口，在不同系统上有不同的实现类。实现了Watchable接口的对象方可注册监视服务，java.nio.file.Path实现了此接口。WatchKey表示Watchable对象和WatchService的关联关系，在注册时被创建。注册完成后，WatchKey将被置为’ready’状态，直到下列三种情况之一发生：  </p>

<ol>
  <li>WatchKey.cancel()被调用</li>
  <li>被监控的目录不存在或不可访问</li>
  <li>WatchService对象被关闭  </li>
</ol>

<p>当文件改动发生时，WatchKey的状态将会被置为”signaled”然后被放入待处理队列中。WatchService提供了<strong>三种从队列中获取WatchKeys的方式：</strong></p>

<ol>
  <li>poll - 返回队列中的一个key。如果没有可用的key，将立即返回null。</li>
  <li>poll(long, TimeUnit) - 如果队列中存在可用的key则将之返回，否则在参数预置的时间内等待可用的key。TimeUnit用来指定前一个参数表示的时间是纳秒、毫秒或是其他的时间单位。
例子：final WatchKey watchKey = watchService.poll(1, TimeUnit.MINUTES);将会等待1分钟</li>
  <li>take - 方法将会等待直到可用的key被返回。</li>
</ol>

<p><strong>获取WatchKey后进行处理：</strong></p>

<ol>
  <li>通过WatchKey.pollEvents()函数得到WatchEvents列表。</li>
  <li>对于每一个WatchEvent，可以通过kind()函数获得其改动类型。</li>
  <li>通过WatchEvent.context()函数得到发生该事件的文件名</li>
  <li>当该key的所有事件处理完成后，需要调用WatchKey.reset()方法把该key重置为ready状态。若不重置，该key将无法接收后续的改动。若reset返回false，表示该WatchKey不再合法，主循环可以退出。</li>
</ol>

<p><figure class='code'><figcaption class='code-header'><span>WatchServiceTest</span> &mdash; <a href='https://github.com/cwind001/CwindJavaLab/blob/163448ce07ecca1738b306bed9bf1b39464d345c/FileMonitor/src/test/java/com/cwind/file/WatchServerTest.java'>link</a></figcaption> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">package</span> <span class="namespace">com.cwind.file</span>;&lt;/p&gt;

&lt;p&gt;<span class="keyword">import</span> <span class="include">java.io.IOException</span>;
<span class="keyword">import</span> <span class="include">java.nio.file.FileSystems</span>;
<span class="keyword">import</span> <span class="include">java.nio.file.Path</span>;
<span class="keyword">import</span> <span class="include">java.nio.file.Paths</span>;
<span class="keyword">import</span> <span class="include">java.nio.file.StandardWatchEventKinds</span>;
<span class="keyword">import</span> <span class="include">java.nio.file.WatchEvent</span>;
<span class="keyword">import</span> <span class="include">java.nio.file.WatchKey</span>;
<span class="keyword">import</span> <span class="include">java.nio.file.WatchService</span>;&lt;/p&gt;

&lt;p&gt;<span class="directive">public</span> <span class="type">class</span> <span class="class">WatchServerTest</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">InterruptedException</span>, 
        <span class="exception">IOException</span> {
        WatchService watchService 
            = FileSystems.getDefault().newWatchService();
        <span class="directive">final</span> Path path = Paths.get(<span class="error">“</span>.<span class="error">”</span>);
        <span class="directive">final</span> WatchKey watchKey = path.register(watchService, 
            StandardWatchEventKinds.ENTRY_MODIFY,
            StandardWatchEventKinds.ENTRY_CREATE,
            StandardWatchEventKinds.ENTRY_DELETE);
        <span class="type">boolean</span> fileNotChanged = <span class="predefined-constant">true</span>;
        <span class="type">int</span> count = <span class="integer">0</span>;
        <span class="keyword">while</span> (fileNotChanged) {
            <span class="directive">final</span> WatchKey wk = watchService.take();
            <span class="predefined-type">System</span>.out.println(<span class="error">“</span>Loop count: <span class="error">“</span> + count);
            <span class="keyword">for</span> (WatchEvent&amp;lt;?&amp;gt; event : wk.pollEvents()) {
                <span class="directive">final</span> Path changed = (Path) event.context();
                <span class="predefined-type">System</span>.out.println(changed + <span class="error">“</span>, <span class="error">“</span> + event.kind());
                <span class="keyword">if</span> (changed.endsWith(<span class="error">“</span>sample1.txt<span class="error">”</span>)) {
                    <span class="predefined-type">System</span>.out.println(<span class="error">“</span>Sample file has changed<span class="error">”</span>);
                }
            }
            <span class="comment">// reset the key</span>
            <span class="type">boolean</span> valid = wk.reset();
            <span class="keyword">if</span> (!valid) {
                <span class="predefined-type">System</span>.out.println(<span class="error">“</span><span class="predefined-type">Key</span> has been unregisterede<span class="error">”</span>);
            }
            count++;
        }
    }
}
</pre></td>
</tr></table>
 </figure><br />
总结，使用WatchService步骤如下：  </p>

<ol>
  <li>创建WatchService</li>
  <li>得到待检测目录的Path</li>
  <li>将目录登记到变化监测名单中</li>
  <li>执行WatchService的take()方法，直到WatchKey到来。</li>
  <li>得到WatchKey后遍历WatchEvent进行检测</li>
  <li>重置key准备下一个事件，继续等待  </li>
</ol>

<p>大多数文件系统实现包含了文件更改通知的本地支持，Watch Service API正是利用了文件系统的这种机制。若文件系统并不支持变更通知机制，Watch Service仍然会轮询文件系统，等待事件产生。</p>

<p><strong>References:</strong>  </p>

<ol>
  <li><a href="http://docs.oracle.com/javase/tutorial/essential/io/notification.html">Watching a Directory for Changes</a></li>
  <li><a href="http://java.dzone.com/articles/using-java-7s-watchservice">Using Java 7’s WatchService to Monitor Directories</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java PropertyDescriptor 应用及源码分析]]></title>
    <link href="http://cwind001.github.io/blog/2014/03/08/java-propertydescriptor/"/>
    <updated>2014-03-08T22:15:28+08:00</updated>
    <id>http://cwind001.github.io/blog/2014/03/08/java-propertydescriptor</id>
    <content type="html"><![CDATA[<p>前文<a href="http://gocwind.com/blog/2014/01/20/java-introspector/">从Introspector谈Java内省机制</a>提到了通过Introspector.getBeanInfo()方法获取属性描述符数组，进而读取属性值的方式，但未对PropertyDescriptor的应用和实现作进一步阐释，在此作个补完。<br />
<!--more-->
<strong>1. 概述</strong><br />
PropertyDescriptor描述Java Bean中通过一对存储器方法（getter / setter）导出的一个属性。我们可以通过该PropertyDescriptor对bean中的该属性进行读取和写入操作，也可以设置其getter / setter。<br />
<img src="http://dl2.iteye.com/upload/attachment/0094/6177/5c9f92d1-c105-38f0-88e5-18f00e4d5531.jpg"> <br />
<a href="http://www.oschina.net/code/explore/gcc-4.5.2/libjava/classpath/java/beans/PropertyDescriptor.java">PropertyDescriptor源码见此</a><br />
<strong>2. 关键接口及内部属性</strong>  </p>

<p><figure class='code'> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
</pre></td>
  <td class="code"><pre> 
<span class="directive">public</span> <span class="predefined-type">PropertyDescriptor</span>(<span class="predefined-type">String</span> name, 
    <span class="predefined-type">Class</span>&lt;?&gt; beanClass) <span class="directive">throws</span> <span class="exception">IntrospectionException</span>  
<span class="directive">public</span> <span class="predefined-type">PropertyDescriptor</span>(<span class="predefined-type">String</span> name, <span class="predefined-type">Class</span>&lt;?&gt; beanClass, 
<span class="predefined-type">String</span> getMethodName, <span class="predefined-type">String</span> setMethodName) <span class="directive">throws</span> <span class="exception">IntrospectionException</span>&lt;br /&gt;
<span class="directive">public</span> <span class="predefined-type">PropertyDescriptor</span>(<span class="predefined-type">String</span> name, 
<span class="predefined-type">Method</span> readMethod, <span class="predefined-type">Method</span> writeMethod) <span class="directive">throws</span> <span class="exception">IntrospectionException</span>  &lt;/p&gt;

&lt;p&gt;<span class="directive">public</span> <span class="predefined-type">Class</span>&amp;lt;?&amp;gt; getPropertyType()&lt;br /&gt;
<span class="directive">public</span> <span class="predefined-type">Method</span> getReadMethod()&lt;br /&gt;
<span class="directive">public</span> <span class="predefined-type">Method</span> getWriteMethod()  &lt;/p&gt;

&lt;p&gt;<span class="directive">public</span> <span class="type">void</span> setReadMethod(<span class="predefined-type">Method</span> readMethod) <span class="directive">throws</span> <span class="exception">IntrospectionException</span>&lt;br /&gt;
<span class="directive">public</span> <span class="type">void</span> setWriteMethod(<span class="predefined-type">Method</span> writeMethod)&lt;br /&gt;
<span class="directive">public</span> <span class="type">boolean</span> equals(<span class="predefined-type">Object</span> o) &lt;br /&gt;
</pre></td>
</tr></table>
 </figure>  </p>

<p>相关的PropertyDescriptor内部属性如下：  </p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre> 
    <span class="predefined-type">Class</span>&amp;lt;?&amp;gt; propertyType;     <span class="comment">//该属性的类型&lt;br /&gt;</span>
    <span class="predefined-type">Method</span> getMethod;     <span class="comment">//getter&lt;br /&gt;</span>
    <span class="predefined-type">Method</span> setMethod;     <span class="comment">//setter&lt;br /&gt;</span>
</pre></div>
</div>
 </figure><br />
还有继承自其父类FeatureDescriptor的功能，用于指定该属性的编程名称<br />
<strong>3. 简单应用</strong><br />
现有Person类如下：  </p>

<p><figure class='code'> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
</pre></td>
  <td class="code"><pre> &lt;br /&gt;
<span class="keyword">package</span> <span class="namespace">com.cwind.property</span>;  &lt;/p&gt;

&lt;p&gt;<span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {&lt;br /&gt;
        <span class="directive">private</span> <span class="predefined-type">String</span> name ;&lt;br /&gt;
        <span class="directive">private</span> <span class="type">int</span> age ;  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    <span class="directive">public</span> Person(){ <span class="local-variable">this</span>.name = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>; <span class="local-variable">this</span>.age = <span class="integer">0</span>; }  
    <span class="directive">public</span> Person(<span class="predefined-type">String</span> name, <span class="type">int</span> age) { <span class="local-variable">super</span>(); <span class="local-variable">this</span>.name = name; 
<span class="local-variable">this</span>. age = age; }  
  
    <span class="directive">public</span> <span class="predefined-type">String</span> getName() { <span class="keyword">return</span> name; }  
    <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) { <span class="local-variable">this</span>. name = name; }  
  
    <span class="directive">public</span> <span class="type">int</span> getAge() { <span class="keyword">return</span> age; }  
    <span class="directive">public</span> <span class="type">void</span> setAge(<span class="type">int</span> age) { <span class="local-variable">this</span>. age = age; }  
     
    <span class="directive">public</span> <span class="predefined-type">String</span> getNameInUpperCase(){  
           <span class="keyword">return</span> <span class="local-variable">this</span> .name .toUpperCase();  
   }  
    <span class="directive">public</span> <span class="type">void</span> setNameToLowerCase(<span class="predefined-type">String</span> name){  
           <span class="local-variable">this</span>.name = name.toLowerCase();  
   }   }   </pre></td>
</tr></table>
 </figure>  
</code></pre>

<p>该类中除了name和age两个属性的标准getter和setter之外，还有增加了一个获取大写name的get方法和一个将name设置为小写的set方法。<br />
在测试类中，首先获得这两个方法对象。  </p>

<p><figure class='code'> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
</pre></td>
  <td class="code"><pre> 
<span class="predefined-type">Class</span> personClass = <span class="predefined-type">Class</span>.forName(<span class="error">“</span>com.cwind.property.Person<span class="error">”</span>);&lt;br /&gt;
<span class="predefined-type">Method</span> read = personClass.getMethod(<span class="error">“</span>getNameInUpperCase<span class="error">”</span>, <span class="predefined-constant">null</span>);&lt;br /&gt;
<span class="predefined-type">Method</span> write = personClass.getMethod(<span class="error">“</span>setNameToLowerCase<span class="error">”</span>, <span class="predefined-type">String</span>.class );  &lt;/p&gt;

&lt;p&gt;<span class="comment">//然后可以通过两种方式构造PropertyDescriptor&lt;br /&gt;</span>
<span class="predefined-type">PropertyDescriptor</span> prop1 = <span class="keyword">new</span> <span class="predefined-type">PropertyDescriptor</span>( <span class="error">“</span>name<span class="error">”</span>, Person.class );
     <span class="comment">//使用其标准getter和setter&lt;br /&gt;</span>
<span class="predefined-type">PropertyDescriptor</span> prop2 = <span class="keyword">new</span> <span class="predefined-type">PropertyDescriptor</span>( <span class="error">“</span>name<span class="error">”</span>, read, write);
     <span class="comment">//使用read和write两个方法对象所自定义的getter和setter  &lt;/p&gt;</span>

&lt;p&gt;<span class="comment">//下面构建一个Person对象&lt;br /&gt;</span>
Person person = <span class="keyword">new</span> Person(<span class="error">“</span>Kobe<span class="error">”</span> , <span class="integer">36</span>);&lt;br /&gt;
<span class="predefined-type">System</span>. out.println(prop1.getReadMethod().invoke(person, <span class="predefined-constant">null</span>));
     <span class="comment">// –实际调用Person.getName(), result: Kobe&lt;br /&gt;</span>
<span class="predefined-type">System</span>. out.println(prop2.getReadMethod().invoke(person, <span class="predefined-constant">null</span>));
     <span class="comment">// –实际调用Person.getNameInUpperCase(), result: KOBE  &lt;/p&gt;</span>

&lt;p&gt;prop1.getWriteMethod().invoke(person, <span class="error">“</span>James<span class="error">”</span>);
     <span class="comment">// –实际调用Person.setName(), person.name被设置为James&lt;br /&gt;</span>
prop2.getWriteMethod().invoke(person, <span class="error">“</span>James<span class="error">”</span>);
     <span class="comment">// –实际调用Person.setNameToLowerCase(), person.name被设置为james </span>
</pre></td>
</tr></table>
 </figure><br />
<strong>4. 源码分析</strong><br />
构造函数1：  </p>

<p><figure class='code'> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
</pre></td>
  <td class="code"><pre> 
<span class="directive">public</span> <span class="predefined-type">PropertyDescriptor</span>(<span class="predefined-type">String</span> name, <span class="predefined-type">Class</span>&lt;?&gt; beanClass)  
        <span class="directive">throws</span> <span class="exception">IntrospectionException</span> {  
        setName(name);     <span class="comment">//设置属性编程名，本例中即'name'  </span>
        <span class="keyword">if</span> (name.length() == <span class="integer">0</span>){  
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">empty property name</span><span class="delimiter">&quot;</span></span>);       
<span class="comment">// 编程名为空则抛出异常  </span>
        }  
        <span class="predefined-type">String</span> caps = <span class="predefined-type">Character</span>.toUpperCase(name.charAt(<span class="integer">0</span>))
     + name.substring(<span class="integer">1</span>);       
<span class="comment">// 标准getter应为getName()或isName(), 先将首字母大写  </span>
        findMethods(beanClass, <span class="string"><span class="delimiter">&quot;</span><span class="content">is</span><span class="delimiter">&quot;</span></span> + caps, <span class="string"><span class="delimiter">&quot;</span><span class="content">get</span><span class="delimiter">&quot;</span></span> + caps, <span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span> + caps);       
<span class="comment">// 参数依次为：类类型，可能的getter函数名1，可能的getter函数名2，setter函数名  </span>
        <span class="keyword">if</span> (getMethod == <span class="predefined-constant">null</span>){
   <span class="comment">// findMethods()设置PropertyDescriptor的getMethod和setMethod属性  </span>
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(  
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot find a is</span><span class="delimiter">&quot;</span></span> + caps + <span class="string"><span class="delimiter">&quot;</span><span class="content"> or get</span><span class="delimiter">&quot;</span></span> + caps + <span class="string"><span class="delimiter">&quot;</span><span class="content"> method</span><span class="delimiter">&quot;</span></span>);  
        }  
        <span class="keyword">if</span> (setMethod == <span class="predefined-constant">null</span>){  
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(  
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot find a </span><span class="delimiter">&quot;</span></span> + caps + <span class="string"><span class="delimiter">&quot;</span><span class="content"> method</span><span class="delimiter">&quot;</span></span> );  
        }  
        propertyType = checkMethods(getMethod, setMethod);       
<span class="comment">// checkMethods()函数用来检测getMethod得到的类型与setMethod的参数类型是否匹配，</span>
<span class="error">若</span><span class="error">匹</span><span class="error">配</span><span class="error">则</span><span class="error">置</span>propertyType<span class="error">为</span><span class="error">该</span><span class="error">类</span><span class="error">型</span>  
    }  
</pre></td>
</tr></table>
 </figure> 
构造函数2：  
`public PropertyDescriptor(String name, Class<?> beanClass, String getMethodName, String setMethodName) throws IntrospectionException<code>  
其实现与构造函数1类似，只是调用findMethods时直接查找指定的getter和setter函数名：  
        </code>findMethods(beanClass, getMethodName, null, setMethodName);<code>  
构造函数3则更加直观，直接设置方法对象  
</code>public PropertyDescriptor(String name, Method readMethod, Method writeMethod) throws IntrospectionException<code>  
两个比较重要的私有辅助函数分别为</code>findMethods()<code>和</code>checkMethods()`，分别看一下其实现<br />
findMethods用来按指定的getter和setter函数名在指定Class中查找getMethod和setMethod，并设置PropertyDescriptor的相关属性   </p>

<p><figure class='code'> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
</pre></td>
  <td class="code"><pre> 
<span class="directive">private</span> <span class="type">void</span> findMethods(<span class="predefined-type">Class</span> beanClass,
 <span class="predefined-type">String</span> getMethodName1, <span class="predefined-type">String</span> getMethodName2, <span class="predefined-type">String</span> setMethodName)
 <span class="directive">throws</span> <span class="exception">IntrospectionException</span> {&lt;br /&gt;
        <span class="keyword">try</span> {&lt;br /&gt;
            <span class="comment">// 首先查找getMethodName1指定的getter (isXXX)&lt;br /&gt;</span>
            <span class="keyword">if</span> (getMethodName1 != <span class="predefined-constant">null</span>) {&lt;br /&gt;
                <span class="keyword">try</span> {&lt;br /&gt;
                    getMethod = beanClass.getMethod(getMethodName1,
     <span class="keyword">new</span> <span class="predefined-type">Class</span>[<span class="integer">0</span>]);&lt;br /&gt;
                }&lt;br /&gt;
                <span class="keyword">catch</span> (<span class="exception">NoSuchMethodException</span> e)&lt;br /&gt;
                {}&lt;br /&gt;
            }&lt;br /&gt;
            <span class="comment">// 若失败，则查找getMethodName2指定的getter (getXXX)&lt;br /&gt;</span>
            <span class="keyword">if</span> (getMethod == <span class="predefined-constant">null</span> &amp;amp;&amp;amp; getMethodName2 != <span class="predefined-constant">null</span>) {&lt;br /&gt;
                <span class="keyword">try</span> {&lt;br /&gt;
                    getMethod = beanClass.getMethod(getMethodName2,
     <span class="keyword">new</span> <span class="predefined-type">Class</span>[<span class="integer">0</span>]);&lt;br /&gt;
                }&lt;br /&gt;
                <span class="keyword">catch</span> (<span class="exception">NoSuchMethodException</span> e)&lt;br /&gt;
                {}&lt;br /&gt;
            }&lt;br /&gt;
            <span class="keyword">if</span> (setMethodName != <span class="predefined-constant">null</span>) {&lt;br /&gt;
                <span class="keyword">if</span> (getMethod != <span class="predefined-constant">null</span>) {&lt;br /&gt;
                    <span class="comment">// 如果得到了getMethod，则通过其返回值类型决定setMethod的参数类型&lt;br /&gt;</span>
                    <span class="predefined-type">Class</span> propertyType = getMethod.getReturnType();&lt;br /&gt;
                    <span class="keyword">if</span> (propertyType == <span class="predefined-type">Void</span>.TYPE) { &lt;br /&gt;
<span class="comment">// 若getter的返回值为Void类型则抛出异常&lt;br /&gt;</span>
                        <span class="predefined-type">String</span> msg
             = <span class="error">“</span>The property<span class="error">’</span>s read method has <span class="keyword">return</span> type <span class="error">‘</span><span class="type">void</span><span class="error">’</span><span class="error">”</span>;&lt;br /&gt;
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(msg);&lt;br /&gt;
                    }  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                <span class="predefined-type">Class</span><span class="type">[]</span> setArgs = <span class="keyword">new</span> <span class="predefined-type">Class</span><span class="type">[]</span> { propertyType };   
                <span class="keyword">try</span> {  
                    setMethod = beanClass.getMethod(setMethodName,
 setArgs);    <span class="comment">// 通过函数名和参数类型获得setMethod  </span>
                }  
                <span class="keyword">catch</span> (<span class="exception">NoSuchMethodException</span> e)  
                {}  
            }  
            <span class="keyword">else</span> <span class="keyword">if</span> (getMethodName1 == <span class="predefined-constant">null</span> &amp;amp;&amp;amp; getMethodName2 == <span class="predefined-constant">null</span>) {   <span class="comment">// getMethodName1和2均为空，则此属性为只写属性，此时遍历bean中的函数， // 返回第一个名称与setMethodName一致且返回类型为Void的单参数函数  </span>
                <span class="predefined-type">Method</span><span class="type">[]</span> methods = beanClass.getMethods();  
                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &amp;lt; methods.length; i++) {  
                    <span class="keyword">if</span> (methods[i].getName().equals(setMethodName)  
                        &amp;amp;&amp;amp; methods[i].getParameterTypes().length == <span class="integer">1</span>  
                        &amp;amp;&amp;amp; methods[i].getReturnType() == <span class="predefined-type">Void</span>.TYPE) {  
                        setMethod = methods[i];  
                        <span class="keyword">break</span>;  
                    }  
                }  
            }  
        }  
    }  
    <span class="keyword">catch</span> (<span class="exception">SecurityException</span> e) {  
        <span class="predefined-type">String</span> msg
     = <span class="string"><span class="delimiter">&quot;</span><span class="content">SecurityException thrown on attempt to access methods.</span><span class="delimiter">&quot;</span></span>;
 <span class="comment">// 作者在纠结要不要修改异常类型  </span>
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(msg);  
    }  
}   </pre></td>
</tr></table>
 </figure> checkMethods方法  
</code></pre>

<p><figure class='code'> <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
</pre></td>
  <td class="code"><pre> 
<span class="directive">private</span> <span class="predefined-type">Class</span>&lt;?&gt; checkMethods(<span class="predefined-type">Method</span> readMethod, <span class="predefined-type">Method</span> writeMethod)
 <span class="directive">throws</span> <span class="exception">IntrospectionException</span> {  
        <span class="predefined-type">Class</span>&lt;?&gt; newPropertyType = propertyType;&lt;br /&gt;
         <span class="comment">// 合法的read方法应该无参同时带有一个非空的返回值类型&lt;br /&gt;</span>
        <span class="keyword">if</span> (readMethod != <span class="predefined-constant">null</span>) {&lt;br /&gt;
            <span class="keyword">if</span> (readMethod.getParameterTypes().length &amp;gt; <span class="integer">0</span>) {&lt;br /&gt;
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(<span class="error">“</span>read method
     has unexpected parameters<span class="error">”</span>);&lt;br /&gt;
            }&lt;br /&gt;
            newPropertyType = readMethod.getReturnType();&lt;br /&gt;
             <span class="keyword">if</span> (newPropertyType == <span class="predefined-type">Void</span>.TYPE) {&lt;br /&gt;
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(<span class="error">“</span>read method
     <span class="keyword">return</span> type is <span class="type">void</span><span class="error">”</span>);&lt;br /&gt;
            }&lt;br /&gt;
        }&lt;br /&gt;
         <span class="comment">// 合法的write方法应该包含一个类型相同的参数&lt;br /&gt;</span>
        <span class="keyword">if</span> (writeMethod != <span class="predefined-constant">null</span>) {&lt;br /&gt;
            <span class="keyword">if</span> (writeMethod.getParameterTypes().length != <span class="integer">1</span>) {
     <span class="comment">// 参数不能超过一个&lt;br /&gt;</span>
                <span class="predefined-type">String</span> msg = <span class="error">“</span>write method
     does not have exactly one parameter<span class="error">”</span> ;&lt;br /&gt;
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(msg);&lt;br /&gt;
            }&lt;br /&gt;
            <span class="keyword">if</span> (readMethod == <span class="predefined-constant">null</span>) {&lt;br /&gt;
                <span class="comment">// 若无read方法，属性类型就应为writeMethod的参数类型&lt;br /&gt;</span>
                newPropertyType = writeMethod.getParameterTypes()[<span class="integer">0</span>];&lt;br /&gt;
            }&lt;br /&gt;
            <span class="keyword">else</span> {&lt;br /&gt;
                <span class="comment">// 检查read方法的返回值类型是否与write方法的参数类型相匹配&lt;br /&gt;</span>
                <span class="keyword">if</span> (newPropertyType != <span class="predefined-constant">null</span>&lt;br /&gt;
                    &amp;amp;&amp;amp; !newPropertyType.isAssignableFrom(&lt;br /&gt;
                        writeMethod.getParameterTypes()[<span class="integer">0</span>])) {&lt;br /&gt;
                     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IntrospectionException</span>(<span class="error">“</span>read and write method&lt;br /&gt;
     are not compatible<span class="error">”</span>);&lt;br /&gt;
                }&lt;br /&gt;
            }&lt;br /&gt;
        }&lt;br /&gt;
         <span class="keyword">return</span> newPropertyType;&lt;br /&gt;
    }&lt;br /&gt;
</pre></td>
</tr></table>
 </figure><br />
最后提一句<code>PropertyDescriptor.equals()</code>,只有当属性类型、标志、读写方法和  <code>PropertyEditorClass</code> 均相同时才认为两个<code>PropertyDescriptor</code>相等  </p>

<p><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="keyword">return</span> samePropertyType&lt;br /&gt;
                &amp;amp;&amp;amp; sameFlags&lt;br /&gt;
                &amp;amp;&amp;amp; sameReadMethod&lt;br /&gt;
                &amp;amp;&amp;amp; sameWriteMethod&lt;br /&gt;
                &amp;amp;&amp;amp; samePropertyEditorClass; 
</pre></div>
</div>
 </figure>   </p>
]]></content>
  </entry>
  
</feed>
