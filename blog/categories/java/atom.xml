<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 辰风君的笔记本]]></title>
  <link href="http://cwind001.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://cwind001.github.io/"/>
  <updated>2015-08-10T00:54:45+08:00</updated>
  <id>http://cwind001.github.io/</id>
  <author>
    <name><![CDATA[辰风君]]></name>
    <email><![CDATA[billchen01@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java读写Excel：Apache POI, JXL与OpenCSV]]></title>
    <link href="http://cwind001.github.io/blog/2015/02/27/apachepoi/"/>
    <updated>2015-02-27T07:53:53+08:00</updated>
    <id>http://cwind001.github.io/blog/2015/02/27/apachepoi</id>
    <content type="html"><![CDATA[<p>前些日子把JXL替换为ApachePOI，原因很简单，JXL在2009年10月已经停止更新，并且不支持Excel 2007 OOXML （.xlsx）格式的文件。事实上把JXL与POI进行比较并不公平，因为JXL只能够操作OLE2格式的Excel（即.xls），而POI则是能够读写xls(x)、doc(x)、ppt(x)的一整套解决方案。<br />
<!--more--></p>

<p>不同版本Excel的行列数限制：  </p>

<p>{% coderay lang:java linenos:false %} <br />
+—————–+———–+————–+———————+
|                 | Max. Rows | Max. Columns | Max. Cols by letter |
+—————–+———–+————–+———————+
| Excel 365*      | 1,048,576 | 16,384       | XFD                 |
| Excel 2013      | 1,048,576 | 16,384       | XFD                 |
| Excel 2010      | 1,048,576 | 16,384       | XFD                 |
| Excel 2007      | 1,048,576 | 16,384       | XFD                 |
| Excel 2003      | 65,536    | 256          | IV                  |
| Excel 2002 (XP) | 65,536    | 256          | IV                  |
| Excel 2000      | 65,536    | 256          | IV                  |
| Excel 97        | 65,536    | 256          | IV                  |
| Excel 95        | 16,384    | 256          | IV                  |
| Excel 5         | 16,384    | 256          | IV                  |
+—————–+———–+————–+———————+<br />
{% endcoderay %} </p>

<p><em>*Excel 365 unverified.</em></p>

<p><strong>JXL - JExcelApi</strong><br />
<a href="http://mvnrepository.com/artifact/net.sourceforge.jexcelapi/jxl/2.6.12">Maven Repo</a><br />
<a href="http://www.andykhan.com/jexcelapi/index.html">官方网站</a><br />
最近更新：Oct 24，2009</p>

<p>{% coderay lang:java linenos:false %}   </p>
<dependency>
 <groupid>net.sourceforge.jexcelapi</groupid>
 <artifactid>jxl</artifactid>
 <version>2.6.12</version>
</dependency>
<p>{% endcoderay %}   </p>

<p>JXL是一个日本人写的简单类库。<a href="http://www.jexcelapi.org/">作者主页</a>。<a href="http://blog.csdn.net/jarvis_java/article/details/4924099">POI和jxl.jar性能比较</a>一贴中提到其性能较poi更高，内存消耗更少。当且仅当目标文档是行数接近但不超过65536的xls格式时成立。  </p>

<p>类图：<br />
{% img http://dl.iteye.com/upload/picture/pic/132574/73b48deb-3ba5-396c-b01c-5546b1aecba0.jpg %}  </p>

<p>{% coderay lang:java linenos:true JXL Demo https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/jxl/JXLDataSheetWriter.java %} <br />
 public static void main(String[] args) {
  try {
   // create writable wookbook
   WritableWorkbook workbook 
	= Workbook.createWorkbook(new File(“jxlOutput.xls”));</p>

<p>// create writable sheet
   WritableSheet sheet = workbook.createSheet(“First Sheet”, 0);
   for(int i = 0; i &lt; data.length; i++) {
    for(int j = 0; j &lt; data[i].length; j++){</p>

<pre><code> // create a cell at position (i, j) and add to the sheet
 Label label = new Label(i, j, data[i][j]);
 sheet.addCell(label);
}    }    workbook.write();    workbook.close();   } catch (IOException | WriteException e) {    e.printStackTrace();   }  } {% endcoderay %} 
</code></pre>

<p><strong>Apache POI</strong><br />
<a href="http://mvnrepository.com/artifact/org.apache.poi/poi">Maven Repo</a><br />
<a href="http://poi.apache.org/">官方网站</a><br />
最近更新：Dec 17，2014  </p>

<p>类图：<br />
{% img http://dl.iteye.com/upload/picture/pic/132576/6230920a-edc2-3e7c-ac23-d4590f095048.jpg %} </p>

<p>{% coderay lang:java linenos:false %}   </p>
<dependency> 
  <groupid>org.apache.poi</groupid>
  <artifactid>poi</artifactid>
  <version>3.10.1</version>
</dependency>

<dependency>
     <groupid>org.apache.poi</groupid>
     <artifactid>poi-ooxml</artifactid>
     <version>3.9</version>
 </dependency>
<p>{% endcoderay %}   </p>

<p><strong>Apache POI API的一些重点：</strong></p>

<ul>
  <li>Apache POI包含 Excel 97(-2007)文件格式(.xls)的Java实现 – HSSF。（彩蛋：H指Horrible）  </li>
  <li>Apache POI包含 Excel 2007 OOXML文件格式(.xlsx)的Java实现 – XSSF。  </li>
  <li>Apache POI的HSSF和XSSF API提供了读写和修改Excel电子表格的功能。  </li>
  <li>Apache POI也提供了SXSSF API（流式XSSF），它是XSSF的扩展，用于写入非常大的excel文件。SXSSF API需求较小的内存，适用于在堆内存受限时处理较大excel文件的情况。  </li>
  <li>可以选择两种模型：Event Model和User Model。Event Model需求较小的内存，流式读取并处理每个单元；User Model更具备面向对象的特征，方便操作。  </li>
  <li>Apache POI提供了对excel附加功能的完美支持，如公式、单元格样式、颜色、字体、数据验证、图像和超链接等。  </li>
</ul>

<p>SpreadSheet API 功能摘要：<br />
{% img http://dl.iteye.com/upload/picture/pic/132578/9b044f00-622e-3a07-9471-3ee912e42819.jpg %} <br />
以下是两个基于XSSF读写xlsx文件的例子：<br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/poi/SimpleDatasheetReader.java">读取xlsx文件</a><br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/poi/SimpleDatasheetWriter.java">写入xlsx文件</a>  </p>

<p><strong>OpenCSV：</strong> <br />
CSV文件以纯文本形式存储表格数据（数字和文本）。OpenCSV是一个用于读写CSV文件的简单Java类库。<br />
<a href="http://mvnrepository.com/artifact/net.sf.opencsv/opencsv/2.3">Maven Repo</a><br />
<a href="http://opencsv.sf.net">官方网站</a><br />
最近更新：Jul 28，2011</p>

<p>{% coderay lang:java linenos:false %}  </p>
<dependency>
 <groupid>net.sf.opencsv</groupid>
 <artifactid>opencsv</artifactid>
 <version>2.3</version>
</dependency>
<p>{% endcoderay %}</p>

<p>OpenCSV将CSV文件中的每一行读取为一个String数组。相应地，写文件时通过<code>csvWriter.writeNext(array)</code>把String数组内容作为一行写入CSV文件</p>

<p>读写CSV文件的例子：<br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/opencsv/ReadCSVDemo.java">读取csv文件内容</a><br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/POITest/src/main/java/com/cwind/opencsv/OpenCSVDemo.java">将xlsx文件内容写入csv</a>  </p>

<p><strong>References:</strong><br />
1. <a href="http://poi.apache.org/spreadsheet/">POI-HSSF and POI-XSSF - Java API To Access Microsoft Excel Format Files</a><br />
2. <a href="http://www.journaldev.com/2562/java-readwrite-excel-file-using-apache-poi-api">Java Read/Write Excel File using Apache POI API</a>  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java文件变更监控的两种实现]]></title>
    <link href="http://cwind001.github.io/blog/2015/01/30/java-file-monitor/"/>
    <updated>2015-01-30T14:25:04+08:00</updated>
    <id>http://cwind001.github.io/blog/2015/01/30/java-file-monitor</id>
    <content type="html"><![CDATA[<p><strong>对文件及文件夹进行修改变更监测有很广泛的应用，例如：</strong>  </p>

<ul>
  <li>通知配置文件的改变  </li>
  <li>跟踪某些关键的系统文件的变化  </li>
  <li>监控某个分区磁盘的整体使用情况  </li>
  <li>系统崩溃时进行自动清理<br />
<!--more--></li>
  <li>自动触发备份进程  </li>
  <li>向服务器上传文件结束时发出通知    </li>
</ul>

<p>下面给出Java的两种实现，源码可以在GitHub上找到 <a href="https://github.com/cwind001/CwindJavaLab/tree/master/FileMonitor">FileMonitor</a></p>

<p><strong>JDK1.6及之前版本: 基于Timer实现</strong><br />
<strong>两个关键类：</strong>  </p>

<ul>
  <li>java.util.Timer  </li>
  <li>java.util.TimerTask</li>
</ul>

<p>Timertask是由Timer执行的实际任务，实现了Rannable接口。通过重写run()方法来指定具体任务细节。<br />
{% img http://dl2.iteye.com/upload/attachment/0105/5397/ddf9a7c5-f08a-3fd3-b1f8-6859e1054bd8.jpg %}</p>

<p><strong>Timer工作原理：</strong><br />
Timer是用于调度一次性执行或重复执行的工具类。通过TaskQueue保存需要调度的TimerTask，当某个Task被废弃时（一次性任务结束或TimerTask.cancel()），将其从该队列中移除。<br />
Timer类维护一个后台线程（守护线程或用户线程，取决于如何创建Timer对象），该线程通常称为Timer任务执行线程。在TimerThread的mainLoop()中依据各个TimerTask的状态和调度时间设定，决定执行或移除TimerTask。<br />
<strong>TimerTask应设计为执行不占用太长时间</strong>，否则同一个Timer队列中其他的TimerTask的执行将会延迟。<br />
更多可参见：<a href="http://javarevisited.blogspot.com/2013/02/what-is-timer-and-timertask-in-java-example-tutorial.html">What is Timer and TimerTask in Java</a></p>

<p><strong>基于Timer的FileMonitor的实现：</strong><br />
{% img http://dl2.iteye.com/upload/attachment/0105/5399/4b7c54fa-cac9-3d7b-85c7-6e655ff8bbcb.jpg %}</p>

<p>通过实现FileChangeObserver接口，该FileMonitor允许对任意文件添加任意多个Observer。<br />
<a href="https://github.com/cwind001/CwindJavaLab/blob/master/FileMonitor/src/main/java/com/cwind/file/FileChangeMonitor.java">FileChangeMonitor及FileChangeTask源码</a><br />
FileChangeMonitor本身是一个单例。fileObservers由Collections.synchronizedMap()初始化，保证在该map上的每一个原子操作都将被同步。在其addObserver方法中为每一个fileChangeObserver创建一个FileChangeTask，将其加入fileObservers中。FileChangeTask扩展了TimerTask，由Timer调度执行。</p>

<p>{% coderay lang:java linenos:true FileChangeMonitor.addObserver() https://github.com/cwind001/CwindJavaLab/blob/master/FileMonitor/src/main/java/com/cwind/file/FileChangeMonitor.java %}
	public void addObserver(FileChangeObserver observer, 
	  String filename, long delay) throws FileNotFoundException {<br />
    	TimerTask task = new FileChangeTask(observer , filename );<br />
    	List<timertask> tasks = fileObservers.get(filename );  
    	if(tasks ==null){  
        	tasks = new ArrayList<timertask>();  
   		}  
    	tasks.add( task);  
    	fileObservers.put(filename , tasks );  
    	timer.schedule( task, delay, delay);  
	}  
{% endcoderay %}  
在FileChangeTask的run()函数中，通过比对时间戳来判断文件是否修改，若发生改动，则通知其Observer进行相应处理。 </timertask></timertask></p>

<p>{% coderay lang:java linenos:true FileChangeTask.run() https://github.com/cwind001/CwindJavaLab/blob/master/FileMonitor/src/main/java/com/cwind/file/FileChangeMonitor.java %}<br />
public void run() {
		try	{
			long newLastModified = file.lastModified();
			if (newLastModified &gt; lastModified) {
				lastModified = newLastModified;
				observer.fileChanged(file.getPath());
			}
		}
		catch (Exception e)	{
			System.err.println(e.getMessage());
		}
	} 
{% endcoderay %} </p>

<p>测试用例<a href="https://github.com/cwind001/CwindJavaLab/blob/163448ce07ecca1738b306bed9bf1b39464d345c/FileMonitor/src/test/java/com/cwind/file/FileMonitorTest.java">FileMonitorTest</a>中为sample1.txt添加了consoleObserver和emailObserver，为sample2.txt添加了consoleObserver。然后对这两个文件分别进行修改。</p>

<p>{% coderay lang:java linenos:true FileMonitorTest https://github.com/cwind001/CwindJavaLab/blob/163448ce07ecca1738b306bed9bf1b39464d345c/FileMonitor/src/test/java/com/cwind/file/FileMonitorTest.java %}
package com.cwind.file;</p>

<p>import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;</p>

<p>import org.junit.After;
import org.junit.Before;
import org.junit.Test;</p>

<p>public class FileMonitorTest {</p>

<pre><code>File sampleFile1, sampleFile2;
FileChangeMonitor monitor;
ConsoleFileChangeObserver consoleObserver;
EmailFileChangeObserver emailObserver;

@Before
public void setUp() throws Exception {
	sampleFile1 = new File("sample1.txt"); 
	sampleFile2 = new File("sample2.txt");
	monitor = FileChangeMonitor.getInstance();
	consoleObserver = new ConsoleFileChangeObserver();
	emailObserver = new EmailFileChangeObserver("billchen01@163.com");
}

@After
public void tearDown() throws Exception	{
	
}

@Test
public void testMonitorSampleFile() throws InterruptedException, 
	IOException{
	monitor.addObserver(consoleObserver, sampleFile1.getPath(), 
		FileChangeMonitor.DELAY_TIME);
	monitor.addObserver(emailObserver, sampleFile1.getPath(), 
		FileChangeMonitor.DELAY_TIME);
	monitor.addObserver(consoleObserver, sampleFile2.getPath(), 
		FileChangeMonitor.DELAY_TIME);
	
	FileOutputStream fos1 = new FileOutputStream(sampleFile1);
	FileOutputStream fos2 = new FileOutputStream(sampleFile2);
	fos1.write(0);
	fos2.write(0);
	fos1.flush();
	fos2.flush();
	fos1.close();
	fos2.close();
	Thread.sleep(3000);
} } {% endcoderay %} 
</code></pre>

<p>输出结果如下：<br />
<code>Console: File sample1.txt is changed, will print warning message to console.</code><br />
<code>File sample1.txt is changed, will send email to billchen01@163.com.</code><br />
<code>Console: File sample2.txt is changed, will print warning message to console.</code>  </p>

<p><strong>JDK 1.7 及之后版本：基于WatchService实现</strong><br />
Java 7 的新IO - NIO.2提供了一组新的类和方法，主要存在于java.nio包内。它完全取代了java.io.File与文件系统的交互，并提供了新的异步处理类，无需手动配置线程池和其他底层并发控制，便可在后台线程中执行文件和网络IO操作。<br />
其中Path是新文件IO的基石。为与之前版本兼容，java.io.File类中新增了toPath()方法，Path类中提供了toFile()方法。
Watch Service API可用于将指定目录注册到监视服务上。注册时须指定事件类型，如文件创建、修改、删除等。相关类图如下：<br />
{% img http://dl2.iteye.com/upload/attachment/0105/5403/f20e959b-2ded-3a35-b984-61f5010f7efb.jpg %}  </p>

<p>WatchService是监视服务接口，在不同系统上有不同的实现类。实现了Watchable接口的对象方可注册监视服务，java.nio.file.Path实现了此接口。WatchKey表示Watchable对象和WatchService的关联关系，在注册时被创建。注册完成后，WatchKey将被置为’ready’状态，直到下列三种情况之一发生：  </p>

<ol>
  <li>WatchKey.cancel()被调用</li>
  <li>被监控的目录不存在或不可访问</li>
  <li>WatchService对象被关闭  </li>
</ol>

<p>当文件改动发生时，WatchKey的状态将会被置为”signaled”然后被放入待处理队列中。WatchService提供了<strong>三种从队列中获取WatchKeys的方式：</strong></p>

<ol>
  <li>poll - 返回队列中的一个key。如果没有可用的key，将立即返回null。</li>
  <li>poll(long, TimeUnit) - 如果队列中存在可用的key则将之返回，否则在参数预置的时间内等待可用的key。TimeUnit用来指定前一个参数表示的时间是纳秒、毫秒或是其他的时间单位。
例子：final WatchKey watchKey = watchService.poll(1, TimeUnit.MINUTES);将会等待1分钟</li>
  <li>take - 方法将会等待直到可用的key被返回。</li>
</ol>

<p><strong>获取WatchKey后进行处理：</strong></p>

<ol>
  <li>通过WatchKey.pollEvents()函数得到WatchEvents列表。</li>
  <li>对于每一个WatchEvent，可以通过kind()函数获得其改动类型。</li>
  <li>通过WatchEvent.context()函数得到发生该事件的文件名</li>
  <li>当该key的所有事件处理完成后，需要调用WatchKey.reset()方法把该key重置为ready状态。若不重置，该key将无法接收后续的改动。若reset返回false，表示该WatchKey不再合法，主循环可以退出。</li>
</ol>

<p>{% coderay lang:java linenos:true WatchServiceTest https://github.com/cwind001/CwindJavaLab/blob/163448ce07ecca1738b306bed9bf1b39464d345c/FileMonitor/src/test/java/com/cwind/file/WatchServerTest.java %}
package com.cwind.file;</p>

<p>import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;</p>

<p>public class WatchServerTest {
	public static void main(String[] args) throws InterruptedException, 
		IOException {
		WatchService watchService 
			= FileSystems.getDefault().newWatchService();
		final Path path = Paths.get(“.”);
		final WatchKey watchKey = path.register(watchService, 
			StandardWatchEventKinds.ENTRY_MODIFY,
			StandardWatchEventKinds.ENTRY_CREATE,
			StandardWatchEventKinds.ENTRY_DELETE);
		boolean fileNotChanged = true;
		int count = 0;
		while (fileNotChanged) {
			final WatchKey wk = watchService.take();
		    System.out.println(“Loop count: “ + count);
		    for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
		        final Path changed = (Path) event.context();
		        System.out.println(changed + “, “ + event.kind());
		        if (changed.endsWith(“sample1.txt”)) {
		            System.out.println(“Sample file has changed”);
		        }
		    }
		    // reset the key
		    boolean valid = wk.reset();
		    if (!valid) {
		        System.out.println(“Key has been unregisterede”);
		    }
		    count++;
		}
	}
}
{% endcoderay %}<br />
总结，使用WatchService步骤如下：  </p>

<ol>
  <li>创建WatchService</li>
  <li>得到待检测目录的Path</li>
  <li>将目录登记到变化监测名单中</li>
  <li>执行WatchService的take()方法，直到WatchKey到来。</li>
  <li>得到WatchKey后遍历WatchEvent进行检测</li>
  <li>重置key准备下一个事件，继续等待  </li>
</ol>

<p>大多数文件系统实现包含了文件更改通知的本地支持，Watch Service API正是利用了文件系统的这种机制。若文件系统并不支持变更通知机制，Watch Service仍然会轮询文件系统，等待事件产生。</p>

<p><strong>References:</strong>  </p>

<ol>
  <li><a href="http://docs.oracle.com/javase/tutorial/essential/io/notification.html">Watching a Directory for Changes</a></li>
  <li><a href="http://java.dzone.com/articles/using-java-7s-watchservice">Using Java 7’s WatchService to Monitor Directories</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java PropertyDescriptor 应用及源码分析]]></title>
    <link href="http://cwind001.github.io/blog/2014/03/08/java-propertydescriptor/"/>
    <updated>2014-03-08T22:15:28+08:00</updated>
    <id>http://cwind001.github.io/blog/2014/03/08/java-propertydescriptor</id>
    <content type="html"><![CDATA[<p>前文<a href="http://gocwind.com/blog/2014/01/20/java-introspector/">从Introspector谈Java内省机制</a>提到了通过Introspector.getBeanInfo()方法获取属性描述符数组，进而读取属性值的方式，但未对PropertyDescriptor的应用和实现作进一步阐释，在此作个补完。<br />
<!--more-->
<strong>1. 概述</strong><br />
PropertyDescriptor描述Java Bean中通过一对存储器方法（getter / setter）导出的一个属性。我们可以通过该PropertyDescriptor对bean中的该属性进行读取和写入操作，也可以设置其getter / setter。<br />
{% img http://dl2.iteye.com/upload/attachment/0094/6177/5c9f92d1-c105-38f0-88e5-18f00e4d5531.jpg %} <br />
<a href="http://www.oschina.net/code/explore/gcc-4.5.2/libjava/classpath/java/beans/PropertyDescriptor.java">PropertyDescriptor源码见此</a><br />
<strong>2. 关键接口及内部属性</strong>  </p>

<p>{% coderay lang:java linenos:true %} 
public PropertyDescriptor(String name, 
	Class<?> beanClass) throws IntrospectionException  
public PropertyDescriptor(String name, Class<?> beanClass, 
String getMethodName, String setMethodName) throws IntrospectionException<br />
public PropertyDescriptor(String name, 
Method readMethod, Method writeMethod) throws IntrospectionException  </p>

<p>public Class&lt;?&gt; getPropertyType()<br />
public Method getReadMethod()<br />
public Method getWriteMethod()  </p>

<p>public void setReadMethod(Method readMethod) throws IntrospectionException<br />
public void setWriteMethod(Method writeMethod)<br />
public boolean equals(Object o) <br />
{% endcoderay %}  </p>

<p>相关的PropertyDescriptor内部属性如下：  </p>

<p>{% coderay lang:java linenos:false %} 
    Class&lt;?&gt; propertyType;     //该属性的类型<br />
    Method getMethod;     //getter<br />
    Method setMethod;     //setter<br />
{% endcoderay %}<br />
还有继承自其父类FeatureDescriptor的功能，用于指定该属性的编程名称<br />
<strong>3. 简单应用</strong><br />
现有Person类如下：  </p>

<p>{% coderay lang:java linenos:true %} <br />
package com.cwind.property;  </p>

<p>public class Person {<br />
        private String name ;<br />
        private int age ;  </p>

<pre><code>    public Person(){ this.name = ""; this.age = 0; }  
    public Person(String name, int age) { super(); this.name = name; 
this. age = age; }  
  
    public String getName() { return name; }  
    public void setName(String name) { this. name = name; }  
  
    public int getAge() { return age; }  
    public void setAge(int age) { this. age = age; }  
     
    public String getNameInUpperCase(){  
           return this .name .toUpperCase();  
   }  
    public void setNameToLowerCase(String name){  
           this.name = name.toLowerCase();  
   }   }   {% endcoderay %}  
</code></pre>

<p>该类中除了name和age两个属性的标准getter和setter之外，还有增加了一个获取大写name的get方法和一个将name设置为小写的set方法。<br />
在测试类中，首先获得这两个方法对象。  </p>

<p>{% coderay lang:java linenos:true %} 
Class personClass = Class.forName(“com.cwind.property.Person”);<br />
Method read = personClass.getMethod(“getNameInUpperCase”, null);<br />
Method write = personClass.getMethod(“setNameToLowerCase”, String.class );  </p>

<p>//然后可以通过两种方式构造PropertyDescriptor<br />
PropertyDescriptor prop1 = new PropertyDescriptor( “name”, Person.class );
     //使用其标准getter和setter<br />
PropertyDescriptor prop2 = new PropertyDescriptor( “name”, read, write);
     //使用read和write两个方法对象所自定义的getter和setter  </p>

<p>//下面构建一个Person对象<br />
Person person = new Person(“Kobe” , 36);<br />
System. out.println(prop1.getReadMethod().invoke(person, null));
     // –实际调用Person.getName(), result: Kobe<br />
System. out.println(prop2.getReadMethod().invoke(person, null));
     // –实际调用Person.getNameInUpperCase(), result: KOBE  </p>

<p>prop1.getWriteMethod().invoke(person, “James”);
     // –实际调用Person.setName(), person.name被设置为James<br />
prop2.getWriteMethod().invoke(person, “James”);
     // –实际调用Person.setNameToLowerCase(), person.name被设置为james 
{% endcoderay %}<br />
<strong>4. 源码分析</strong><br />
构造函数1：  </p>

<p>{% coderay lang:java linenos:true %} 
public PropertyDescriptor(String name, Class<?> beanClass)  
        throws IntrospectionException {  
        setName(name);     //设置属性编程名，本例中即&#8217;name&#8217;  
        if (name.length() == 0){  
            throw new IntrospectionException(&#8220;empty property name&#8221;);       
// 编程名为空则抛出异常  
        }  
        String caps = Character.toUpperCase(name.charAt(0))
	 + name.substring(1);       
// 标准getter应为getName()或isName(), 先将首字母大写  
        findMethods(beanClass, &#8220;is&#8221; + caps, &#8220;get&#8221; + caps, &#8220;set&#8221; + caps);       
// 参数依次为：类类型，可能的getter函数名1，可能的getter函数名2，setter函数名  
        if (getMethod == null){
   // findMethods()设置PropertyDescriptor的getMethod和setMethod属性  
            throw new IntrospectionException(  
                &#8220;Cannot find a is&#8221; + caps + &#8221; or get&#8221; + caps + &#8221; method&#8221;);  
        }  
        if (setMethod == null){  
            throw new IntrospectionException(  
                &#8220;Cannot find a &#8221; + caps + &#8221; method&#8221; );  
        }  
        propertyType = checkMethods(getMethod, setMethod);       
// checkMethods()函数用来检测getMethod得到的类型与setMethod的参数类型是否匹配，
若匹配则置propertyType为该类型  
    }  
{% endcoderay %} 
构造函数2：  
`public PropertyDescriptor(String name, Class<?> beanClass, String getMethodName, String setMethodName) throws IntrospectionException<code>  
其实现与构造函数1类似，只是调用findMethods时直接查找指定的getter和setter函数名：  
        </code>findMethods(beanClass, getMethodName, null, setMethodName);<code>  
构造函数3则更加直观，直接设置方法对象  
</code>public PropertyDescriptor(String name, Method readMethod, Method writeMethod) throws IntrospectionException<code>  
两个比较重要的私有辅助函数分别为</code>findMethods()<code>和</code>checkMethods()`，分别看一下其实现<br />
findMethods用来按指定的getter和setter函数名在指定Class中查找getMethod和setMethod，并设置PropertyDescriptor的相关属性   </p>

<p>{% coderay lang:java linenos:true %} 
private void findMethods(Class beanClass,
 String getMethodName1, String getMethodName2, String setMethodName)
 throws IntrospectionException {<br />
        try {<br />
            // 首先查找getMethodName1指定的getter (isXXX)<br />
            if (getMethodName1 != null) {<br />
                try {<br />
                    getMethod = beanClass.getMethod(getMethodName1,
	 new Class[0]);<br />
                }<br />
                catch (NoSuchMethodException e)<br />
                {}<br />
            }<br />
            // 若失败，则查找getMethodName2指定的getter (getXXX)<br />
            if (getMethod == null &amp;&amp; getMethodName2 != null) {<br />
                try {<br />
                    getMethod = beanClass.getMethod(getMethodName2,
	 new Class[0]);<br />
                }<br />
                catch (NoSuchMethodException e)<br />
                {}<br />
            }<br />
            if (setMethodName != null) {<br />
                if (getMethod != null) {<br />
                    // 如果得到了getMethod，则通过其返回值类型决定setMethod的参数类型<br />
                    Class propertyType = getMethod.getReturnType();<br />
                    if (propertyType == Void.TYPE) { <br />
// 若getter的返回值为Void类型则抛出异常<br />
                        String msg
			 = “The property’s read method has return type ‘void’”;<br />
                        throw new IntrospectionException(msg);<br />
                    }  </p>

<pre><code>                Class[] setArgs = new Class[] { propertyType };   
                try {  
                    setMethod = beanClass.getMethod(setMethodName,
 setArgs);    // 通过函数名和参数类型获得setMethod  
                }  
                catch (NoSuchMethodException e)  
                {}  
            }  
            else if (getMethodName1 == null &amp;&amp; getMethodName2 == null) {   // getMethodName1和2均为空，则此属性为只写属性，此时遍历bean中的函数， // 返回第一个名称与setMethodName一致且返回类型为Void的单参数函数  
                Method[] methods = beanClass.getMethods();  
                for (int i = 0; i &lt; methods.length; i++) {  
                    if (methods[i].getName().equals(setMethodName)  
                        &amp;&amp; methods[i].getParameterTypes().length == 1  
                        &amp;&amp; methods[i].getReturnType() == Void.TYPE) {  
                        setMethod = methods[i];  
                        break;  
                    }  
                }  
            }  
        }  
    }  
    catch (SecurityException e) {  
        String msg
	 = "SecurityException thrown on attempt to access methods.";
 // 作者在纠结要不要修改异常类型  
        throw new IntrospectionException(msg);  
    }  
}   {% endcoderay %} checkMethods方法  
</code></pre>

<p>{% coderay lang:java linenos:true %} 
private Class<?> checkMethods(Method readMethod, Method writeMethod)
 throws IntrospectionException {  
        Class<?> newPropertyType = propertyType;<br />
         // 合法的read方法应该无参同时带有一个非空的返回值类型<br />
        if (readMethod != null) {<br />
            if (readMethod.getParameterTypes().length &gt; 0) {<br />
                throw new IntrospectionException(“read method
	 has unexpected parameters”);<br />
            }<br />
            newPropertyType = readMethod.getReturnType();<br />
             if (newPropertyType == Void.TYPE) {<br />
                throw new IntrospectionException(“read method
	 return type is void”);<br />
            }<br />
        }<br />
         // 合法的write方法应该包含一个类型相同的参数<br />
        if (writeMethod != null) {<br />
            if (writeMethod.getParameterTypes().length != 1) {
	 // 参数不能超过一个<br />
                String msg = “write method
	 does not have exactly one parameter” ;<br />
                throw new IntrospectionException(msg);<br />
            }<br />
            if (readMethod == null) {<br />
                // 若无read方法，属性类型就应为writeMethod的参数类型<br />
                newPropertyType = writeMethod.getParameterTypes()[0];<br />
            }<br />
            else {<br />
                // 检查read方法的返回值类型是否与write方法的参数类型相匹配<br />
                if (newPropertyType != null<br />
                    &amp;&amp; !newPropertyType.isAssignableFrom(<br />
                        writeMethod.getParameterTypes()[0])) {<br />
                     throw new IntrospectionException(“read and write method<br />
	 are not compatible”);<br />
                }<br />
            }<br />
        }<br />
         return newPropertyType;<br />
    }<br />
{% endcoderay %}<br />
最后提一句<code>PropertyDescriptor.equals()</code>,只有当属性类型、标志、读写方法和  <code>PropertyEditorClass</code> 均相同时才认为两个<code>PropertyDescriptor</code>相等  </p>

<p>{% coderay lang:java linenos:false %}
return samePropertyType<br />
                &amp;&amp; sameFlags<br />
                &amp;&amp; sameReadMethod<br />
                &amp;&amp; sameWriteMethod<br />
                &amp;&amp; samePropertyEditorClass; 
{% endcoderay %}   </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Introspector谈Java内省机制]]></title>
    <link href="http://cwind001.github.io/blog/2014/01/20/java-introspector/"/>
    <updated>2014-01-20T22:00:51+08:00</updated>
    <id>http://cwind001.github.io/blog/2014/01/20/java-introspector</id>
    <content type="html"><![CDATA[<p><strong>内省</strong><br />
内省是Java语言的一种重要特性。使用内省我们可以在运行时得到一个类的内部信息。这些信息包括方法、属性、构造函数及其他。内省的一个应用是开发使用插件的应用程序。应用程序可以在运行时获取并使用插件类的构造函数、方法和属性。内省也可以应用于创建Java Beans和Javadocs中。<br />
<!--more-->
<strong>Introspector类</strong><br />
Introspector类为访问目标Jave Bean支持的属性、事件和方法提供了标准方法。该方法可用于工具类（如BeanUtils）中。<br />
对于属性、事件和方法中的每一类信息，Introspector会分别分析目标bean以及其父类，寻找显式或隐式信息并用其构建一个能够全面描述目标bean的BeanInfo对象。<br />
{% img http://dl2.iteye.com/upload/attachment/0093/3705/b0194712-7259-3d67-9f84-da5282bee5cb.jpg %}<br />
通过调用Introspector.getBeanInfo()方法来获得指定类的bean信息。Java Bean规范允许通过实现BeanInfo接口，定义一个对象来描述bean。为了将BeanInfo与bean关联起来，须遵守如下命名模式：bean信息类的名字必须是将”BeanInfo”添加到bean名字的后面构成。例如：  </p>

<p>{% coderay lang:java linenos:true %} 
package com.cwind.introspector;  </p>

<p>public class Ultraman extends Superhero {<br />
        public String avanta ;  </p>

<pre><code>    public Ultraman(String avanta) {  
           super ();  
           this .avanta = avanta;  
   }  
  
    public String getAvanta() {  
           return avanta ;  
   }  
  
    public void setAvanta(String avanta) {  
           this .avanta = avanta;  
   }   }   {% endcoderay %}   相关信息类：
</code></pre>

<p>{% coderay lang:java linenos:true %} 
package com.cwind.introspector;  </p>

<p>import java.beans.IntrospectionException;<br />
import java.beans.PropertyDescriptor;<br />
import java.beans.SimpleBeanInfo;  </p>

<p>public class UltramanBeanInfo extends SimpleBeanInfo {<br />
        public PropertyDescriptor[] getPropertyDescriptors() {<br />
               try {<br />
                      return new PropertyDescriptor[]{<br />
                        new PropertyDescriptor(“avanta” , Ultraman. class),<br />
                        new PropertyDescriptor(“name” , Ultraman. class)<br />
                     };<br />
              } catch (IntrospectionException e) {<br />
                     e.printStackTrace();<br />
                      return null ;<br />
              }<br />
       }<br />
}<br />
{% endcoderay %}
信息类会先从Bean类所在的包内查找，如上例中搜索路径为com.cwind.introspector.UltramanBeanInfo。搜索路径也可以通过Introspector.setBeanInfoSearchPath()进行设置。使用BeanInfo类是为了获取对bean属性的控制权。只需提供属性名和所属的bean类，就可以为每个属性构建一个PropertyDescriptor。
演示类Superhero及其另一子类Titan定义：  </p>

<p>{% coderay lang:java linenos:true %} 
package com.cwind.introspector;  </p>

<p>public class Superhero {<br />
     private String name ;<br />
     private String superPower ;<br />
     private int age ;  </p>

<pre><code> public Superhero(){  
      this.name = "defaultName" ;  
      this.superPower  = "defaultSuperPower" ;  
      this.age = 0;  
 }  
     
 public Superhero(String name, String superPower, int age) {  
      super();  
      this.name = name;  
      this.superPower = superPower;  
      this.age = age;  
 }  
  
 public String getName() {  
      return name ;  
 }  
 public void setName(String name) {  
      this.name = name;  
 }  
 public String getSuperPower() {  
      return superPower ;  
 }  
 public void setSuperPower(String superPower) {  
      this.superPower = superPower;  
 }  
 public int getAge() {  
      return age ;  
 }  
 public void setAge(int age) {  
      this.age = age;  
 }   }  
</code></pre>

<p>package com.cwind.introspector;  </p>

<p>public class Titan extends Superhero {<br />
     private double height ;<br />
     private double weight ;  </p>

<pre><code> public Titan(double height, double weight) {  
      super();  
      this.height = height;  
      this.weight = weight;  
 }  
     
 public double getHeight() {  
      return height ;  
 }  
 public void setHeight(double height) {  
      this.height = height;  
 }  
 public double getWeight() {  
      return weight ;  
 }  
 public void setWeight(double weight) {  
      this.weight = weight;  
 }     }   {% endcoderay %}   可以看到，Ultraman类有一个显式的BeanInfo类，其中的属性描述符仅包括"avanta"和继承自父类的"name"。Titan没有显式的BeanInfo类。下面用一个测试类来打印Introspector获取的BeanInfo信息，分别打印两个Ultraman和Titan实例的属性名称及其对应的值，比较其异同。  
</code></pre>

<p>{% coderay lang:java linenos:true %} 
package com.cwind.introspector;  </p>

<p>import java.beans.IntrospectionException;<br />
import java.beans.Introspector;<br />
import java.beans.PropertyDescriptor;<br />
import java.lang.reflect.InvocationTargetException;  </p>

<p>public class IntrospectorTest {<br />
     public static void main(String[] args) 
	throws IntrospectionException, IllegalArgumentException,
	 IllegalAccessException, InvocationTargetException{<br />
          PropertyDescriptor[] ultramanProps 
	= Introspector.getBeanInfo(Ultraman.class).getPropertyDescriptors();<br />
          Ultraman sailor = new Ultraman(“sailor” );<br />
          for(PropertyDescriptor prop : ultramanProps){
               System. out.println(“Property name: “ + prop.getName()
		+ “, value: “+ prop.getReadMethod().invoke(sailor, null));<br />
          }<br />
          System. out.println();<br />
          PropertyDescriptor[] titanProps 
	= Introspector.getBeanInfo(Titan.class).getPropertyDescriptors();<br />
          Titan titan = new Titan(999,888);<br />
          for(PropertyDescriptor prop : titanProps){<br />
               System. out.println(“Property name: “ + prop.getName()
		+ “, value: “+ prop.getReadMethod().invoke(titan, null));<br />
          }<br />
     }<br />
}<br />
{% endcoderay %} <br />
输出结果如下：</p>

<p>{% coderay lang:java linenos:true %} 
Property name: avanta, value: sailor<br />
Property name: name, value: defaultName  </p>

<p>Property name: age, value: 0<br />
Property name: class, value: class com.cwind.introspector.Titan<br />
Property name: height, value: 999.0<br />
Property name: name, value: defaultName<br />
Property name: superPower, value: defaultSuperPower<br />
Property name: weight, value: 888.0<br />
{% endcoderay %} <br />
可以看到，对于前者，只打印出其显式BeanInfo类中返回的属性描述符所对应的属性；对于后者，使用低层次的反射来获取所有属性，并按照属性名称字母序将属性描述符数组返回。
为了更好的性能，Introspector缓存BeanInfo；因此，若在使用多个类加载器的应用程序中使用Introspector须小心谨慎。可以调用Introspector.flushCaches或Introspector.flushFromCaches方法从缓存中清空内省的类。<br />
<strong>Reference：</strong><br />
1. <a href="http://docs.oracle.com/javase/6/docs/api/">Java API 1.6</a><br />
2. <a href="http://my.oschina.net/zookeeper/blog/179269">Java反射总结</a><br />
3. <a href="http://blog.csdn.net/hahalzb/article/details/5972421">Java内省机制</a><br />
4. <a href="http://www.blogjava.net/wiflish/archive/2007/03/05/101964.html">Java语言的反射和内省</a><br />
5. <a href="http://www.codeproject.com/Articles/235269/Using-Introspection-in-Java">Using Introspection in Java</a><br />
6. Java2核心技术 卷II：高级特性，第8章：JavaBean构件；【美】Cay S. Horstmann, Gary Cornell 著；机械工业出版社</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java时区转换与时间格式]]></title>
    <link href="http://cwind001.github.io/blog/2013/07/17/java-timezone-convertion/"/>
    <updated>2013-07-17T21:26:56+08:00</updated>
    <id>http://cwind001.github.io/blog/2013/07/17/java-timezone-convertion</id>
    <content type="html"><![CDATA[<p>本文介绍Java API 中 Date, Calendar, TimeZone和DateFormat的使用，以及不同时区时间相互转化的方法和原理。
<!--more--></p>

<p><strong>问题描述：</strong>
向处于不同时区的服务器发请求时需要考虑时区转换的问题。譬如，服务器位于东八区（北京时间，GMT+8:00），而身处东四区的用户想要查询当天的销售记录。则需把东四区的“今天”这个时间范围转换为服务器所在时区的时间范围。</p>

<p><em>Tips1. GMT时间：</em>即格林威治平时（Greenwich Mean Time）。平太阳时是与视太阳时对应的，由于地球轨道非圆形，运行速度岁地球与太阳距离改变而出现变化，因此视太阳时欠缺均匀性。为了纠正这种不均匀性，天文学家计算地球非圆形轨迹与极轴倾斜对视太阳时的效应。平太阳时就是指经修订之后的视太阳时。在格林威治子午线上的平太阳时称为世界时（UTC），又叫格林威治平时（GMT）。</p>

<p>类Date表示特定的瞬间，精确到毫秒。获得一个表示当前时间的Date对象有两种方式：   </p>

<p>{% coderay lang:java linenos:false %} <br />
Date date = new Date();<br />
Date date = Calendar.getInstance().getTime();<br />
{% endcoderay %} </p>

<p><strong>Date</strong>对象本身所存储的毫秒数可以通过date.getTime()方法得到；该函数返回自1970年1月1日 00:00:00 GMT以来此对象表示的毫秒数。</p>

<p><strong>Calendar</strong>的getInstance()方法有参数为TimeZone和Locale的重载，可以使用指定时区和语言环境获得一个日历。无参则使用默认时区和语言环境获得日历。</p>

<p><strong>TimeZone</strong>表示时区偏移量，本质上以毫秒数保存与GMT的差值。获取TimeZone可以通过时区ID，如”America/New_York”，也可以通过GMT+/-hh:mm来设定。例如北京时间可以表示为GMT+8:00。
TimeZone.getRawOffset()方法可以用来得到当前时区的标准时间到GMT的偏移量。上段提到的”America/New_York”和”GMT+8:00”两个时区的偏移量分别为-18000000和28800000。</p>

<p>于是问题就简单了，在时区间转换时间时，首先用原时间减掉原时间所在时区相对于GMT的偏移量，得到原时间相对与GMT的值，再加上目标时区相对GMT的偏移量即可。
这样得到的结果依然是毫秒数，需要按照指定日期格式重新转换成Date对象。</p>

<p>{% coderay lang:java linenos:true %} <br />
import java.text.<em>;  <br />
import java.util.</em>;    </p>

<p>public class DateTransformer<br />
{<br />
    public static final String DATE_FORMAT = “MM/dd/yyyy HH:mm:ss”;  </p>

<pre><code>public static String dateTransformBetweenTimeZone(Date sourceDate, 
DateFormat formatter,  
    TimeZone sourceTimeZone, TimeZone targetTimeZone) {  
    Long targetTime = sourceDate.getTime()
 		- sourceTimeZone.getRawOffset() + targetTimeZone.getRawOffset();  
    return DateTransformer.getTime(new Date(targetTime), formatter);  
}  
     
public static String getTime(Date date, DateFormat formatter){  
   return formatter.format(date);  
}  
     
public static void main(String[] args){  
    DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);  
    Date date = Calendar.getInstance().getTime();  
    TimeZone srcTimeZone = TimeZone.getTimeZone("EST");  
    TimeZone destTimeZone = TimeZone.getTimeZone("GMT+8");  
    System.out.println(DateTransformer.dateTransformBetweenTimeZone(
date, formatter, srcTimeZone, destTimeZone));  
}   }   {% endcoderay %}   *Tips2. 字面大数字赋值给long类型变量的问题* 上面函数中的targetTime是计算得来的，测试用例中我们可能需要通过毫秒数来构建几个日期对象，但是在赋值long time = 1374004799999 时会提示错误“The literal1374004799999 of type int is out of range”。代码中的数字字面值是int类型，因此超出了长度。在大数字后面加个'L'，long time = 1374004799999L即可正确赋值。 
</code></pre>

<p>DateFormat是是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。SimpleDateFormat则是一个以与语言环境有关的方式来格式化和解析日期的具体类，可以以“日期和时间模式”字符串指定日期和时间格式。我们函数中所用模式字符串为”MM/dd/yyyy HH:mm:ss”，则输出日期：”07/16/2013 04:00:00”</p>

<p>其他常见的模式字母定义如下：  </p>

<p>{% coderay lang:java linenos:false %} <br />
字母 日期或时间元素 表示 示例
G	Era 标志符	Text	AD
y	年	Year	1996; 96
M	年中的月份	Month	July; Jul; 07
w	年中的周数	Number	27
W	月份中的周数	Number	2
D	年中的天数	Number	189
d	月份中的天数	Number	10
F	月份中的星期	Number	2
E	星期中的天数	Text	Tuesday; Tue
a	Am/pm 标记	Text	PM
H	一天中的小时数（0-23）	Number	0
k	一天中的小时数（1-24）	Number	24
K	am/pm 中的小时数（0-11）	Number	0
h	am/pm 中的小时数（1-12）	Number	12
m	小时中的分钟数	Number	30
s	分钟中的秒数	Number	55
S	毫秒数	Number	978
z	时区	General time zone	Pacific Standard Time; PST; GMT-08:00
Z	时区	RFC 822 time zone	-0800
{% endcoderay %} </p>

<p><strong>References:</strong><br />
1. <a href="http://www.javaweb.cc/help/JavaAPI1.6/">Java API 1.6</a><br />
2. <a href="http://www.blogjava.net/liudawei/articles/387891.html">Java时区的转换</a><br />
3. <a href="http://www.cnblogs.com/mailingfeng/archive/2012/06/20/2556326.html">java时区-DateFormat和TimeZone关系</a><br />
4. <a href="http://blog.sina.com.cn/s/blog_4c44d3110100w0gn.html">java获取当前时区的时间</a>  </p>
]]></content>
  </entry>
  
</feed>
